<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Gestion de Projet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdn.dhtmlx.com/gantt/8.0/dhtmlxgantt.js"></script>
  <link rel="stylesheet" href="https://cdn.dhtmlx.com/gantt/8.0/dhtmlxgantt.css">
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      display: flex;
      height: 100vh;
      margin: 0;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      overflow: hidden;
    }
    .sidebar {
      width: 380px;
      min-width: 380px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.95);
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
      overflow-y: auto;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      transition: min-width 0.35s ease, width 0.35s ease, padding 0.35s ease, opacity 0.35s ease;
    }
    .sidebar.collapsed {
        width: 0;
        min-width: 0;
        padding-left: 0;
        padding-right: 0;
        opacity: 0;
    }
    .main {
      flex-grow: 1;
      padding: 10px;
      display: flex;
      flex-direction: column;
      transition: padding 0.35s ease;
    }
    .gantt-container {
      background: rgba(255, 255, 255, 0.95);
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 10px;
      height: 100%;
      box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
      display: flex;
      flex-direction: column;
    }
    .notification-stack {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 1055;
    }
    .notification {
      position: relative;
      padding: 15px 40px 15px 25px;
      border-radius: 50px;
      color: white;
      background: linear-gradient(45deg, #56ab2f, #a8e6cf);
      animation: slideIn 0.5s ease forwards;
    }
    .notification.error {
      background: linear-gradient(45deg, #ff416c, #ff4b2b);
    }
    .notification.warning {
        background: linear-gradient(45deg, #ff9966, #ff8c42);
    }
    .notification .close-btn {
        position: absolute;
        top: 50%;
        right: 15px;
        transform: translateY(-50%);
        font-size: 20px;
        font-weight: bold;
        color: white;
        cursor: pointer;
        line-height: 1;
    }
    @keyframes slideIn {
      from { opacity: 0; transform: translateX(100px); }
      to { opacity: 1; transform: translateX(0); }
    }
    .btn, .form-control, .form-select, .card, .accordion-button, .modal-content {
      border-radius: 15px;
    }
    #gantt_here {
      width: 100%;
      height: 100%;
      border-radius: 15px;
      flex-grow: 1;
    }
    .task-item {
      background: rgba(255, 255, 255, 0.8);
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 8px;
      border-left: 4px solid transparent;
      transition: all 0.3s ease;
    }
     .member-item {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 5px;
    }
    .member-info {
        flex-grow: 1;
    }
    .overload-dropdown {
        flex-basis: 100%;
        margin-top: 5px;
    }
    .member-indicator {
      width: 16px;
      height: 16px;
      display: inline-block;
      border-radius: 50%;
      margin-right: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .gantt_task_line {
      border-radius: 4px;
      border: 1px solid;
    }
    .gantt_task_line.task-locked {
        opacity: 0.6;
        border-style: dashed;
    }
    /* Styles pour le surlignage de surcharge */
    .gantt_row.overload-highlight-warning, .gantt_task_line.overload-highlight-warning {
        background-color: #FFA500 !important; /* Orange Vif */
    }
    .gantt_row.overload-highlight-error, .gantt_task_line.overload-highlight-error {
        background-color: #FF0000 !important; /* Rouge Vif */
    }
    .gantt_row.overload-highlight-warning .gantt_cell,
    .gantt_row.overload-highlight-error .gantt_cell {
        color: white !important;
        font-weight: bold;
    }
    .gantt_task_progress {
      border-radius: 4px;
      opacity: 1;
    }
    .gantt_task_content {
      color: #333;
    }
    .gantt_task_cell.weekend {
      background-color: #f0f0f0 !important;
    }
    .gantt_grid_cell_lock {
        text-align: center;
        cursor: pointer;
    }
    .gantt-controls {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      margin-bottom: 10px;
      flex-shrink: 0;
      padding: 8px 10px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 15px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      gap: 8px;
    }
    .gantt-controls .btn {
      white-space: nowrap;
      margin-right: 0px !important;
    }
    .gantt_grid_data .gantt_cell[role=gridcell][data-column-name=members] {
      cursor: pointer;
    }
    .gantt_grid_data .gantt_cell[role=gridcell][data-column-name=members]:hover {
      background-color: #e9ecef;
    }
    .gantt_grid_resizer {
        position: absolute;
        top: 0;
        right: -1px;
        width: 5px;
        height: 100%;
        cursor: col-resize !important;
        z-index: 10;
        background-color: transparent;
        transition: background-color 0.2s;
    }
    .gantt_grid_resizer:hover {
        background-color: rgba(0, 123, 255, 0.5);
    }
    .priority-low { background-color: #d4edda !important; }
    .priority-medium { background-color: #fff3cd !important; }
    .priority-high { background-color: #f8d7da !important; }
    .language-selector { margin-bottom: 10px; text-align: center; }
    .language-selector button { margin: 0 3px; padding: 5px 8px; font-size: 0.9em; }
    .sidebar-content { flex-grow: 1; overflow-y: auto; }
    .custom-lightbox-members-list {
        max-height: 150px;
        overflow-y: auto;
        border: 1px solid #ced4da;
        padding: 10px;
        border-radius: 0.375rem;
        background-color: #fff;
    }
    .mb-3 { margin-bottom: 0.75rem !important; }
    .mb-2 { margin-bottom: 0.4rem !important; }
    #summaryTaskNote {
        font-size: 0.85em;
        color: #6c757d;
        margin-top: 5px;
        margin-bottom: 15px;
        padding: 10px;
        border: 1px solid #e9ecef;
        border-radius: 8px;
        background-color: #f8f9fa;
    }
  </style>
</head>
<body>
  <div class="sidebar">
    <div class="language-selector">
      <button class="btn btn-sm btn-light" onclick="setLanguage('fr')">FR</button>
      <button class="btn btn-sm btn-light" onclick="setLanguage('en')">EN</button>
      <button class="btn btn-sm btn-light" onclick="setLanguage('es')">ES</button>
      <button class="btn btn-sm btn-light" onclick="setLanguage('de')">DE</button>
      <button class="btn btn-sm btn-light" onclick="setLanguage('it')">IT</button>
    </div>
    <div class="mb-3">
      <button class="btn btn-primary w-100 mb-2" onclick="exportToJSON()" data-translate-key="export">üíæ Exporter</button>
      <input type="file" id="importJSON" name="importJSON" accept=".json" style="display: none;" onchange="importFromJSON(event)">
      <button class="btn btn-secondary w-100 mb-2" onclick="document.getElementById('importJSON').click()" data-translate-key="import">üìÇ Importer</button>
      <button class="btn btn-danger w-100 mb-2" onclick="confirmClearAllData()" data-translate-key="clear_all_data_btn">üóëÔ∏è Vider tout</button>
    </div>
    <div class="sidebar-content">
      <div class="accordion" id="sidebarAccordion">
        <div class="accordion-item">
          <h2 class="accordion-header">
            <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#membersCollapse" data-translate-key="members_section_title">
              üë• Membres
            </button>
          </h2>
          <div id="membersCollapse" class="accordion-collapse collapse show" data-bs-parent="#sidebarAccordion">
            <div class="accordion-body">
              <input id="editMemberId" name="editMemberId" type="hidden" value="">
              <label for="memberName"></label><input id="memberName" name="memberName" class="form-control mb-2" data-translate-placeholder-key="member_name_placeholder">
              <label for="memberColor"></label><input type="color" id="memberColor" name="memberColor" class="form-control mb-2" value="#667eea">
              <button id="memberActionBtn" class="btn btn-primary w-100" onclick="addOrUpdateMember()" data-translate-key="add_member_btn">Ajouter Membre</button>
              <div id="membersList" class="mt-3"></div>
            </div>
          </div>
        </div>
        <div class="accordion-item">
          <h2 class="accordion-header">
            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#projectCollapse" data-translate-key="projects_section_title">
              üìÅ Projets
            </button>
          </h2>
          <div id="projectCollapse" class="accordion-collapse collapse" data-bs-parent="#sidebarAccordion">
            <div class="accordion-body">
              <label for="projectName"></label><input id="projectName" name="projectName" class="form-control mb-2" data-translate-placeholder-key="project_name_placeholder">
              <label for="projectDescription"></label><textarea id="projectDescription" name="projectDescription" class="form-control mb-2" data-translate-placeholder-key="project_description_placeholder" rows="2"></textarea>
              <label for="projectDeadline"></label><input type="text" id="projectDeadline" name="projectDeadline" class="form-control mb-2">
              <label for="projectPriority"></label><select id="projectPriority" name="projectPriority" class="form-select mb-2">
                <option value="low" data-translate-key="priority_low">üü¢ Basse</option>
                <option value="medium" data-translate-key="priority_medium">üü° Moyenne</option>
                <option value="high" data-translate-key="priority_high">üî¥ Haute</option>
              </select>
              <label for="projectColor"></label><input type="color" id="projectColor" name="projectColor" class="form-control mb-2" value="#28a745">
              <button class="btn btn-success w-100" onclick="addProject()" data-translate-key="create_project_btn">Cr√©er Projet</button>
              <div id="projectList"></div>
            </div>
          </div>
        </div>
        <div class="accordion-item">
          <h2 class="accordion-header">
            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#taskCollapse" data-translate-key="new_task_section_title">
              ‚úÖ Nouvelle T√¢che
            </button>
          </h2>
          <div id="taskCollapse" class="accordion-collapse collapse" data-bs-parent="#sidebarAccordion">
            <div class="accordion-body">
              <div class="mb-3">
                  <label for="taskType" class="form-label" data-translate-key="task_type_label">Type de t√¢che</label>
                  <select id="taskType" name="taskType" class="form-select mb-2" onchange="toggleNewTaskFieldsVisibility()">
                      <option value="task" data-translate-key="task_type_normal">T√¢che normale</option>
                      <option value="project" data-translate-key="task_type_mother">T√¢che m√®re (Nouveau Groupe)</option>
                  </select>
                  <p id="summaryTaskNote" style="display: none;" data-translate-key="mother_task_creation_note"></p>
              </div>

              <label for="taskName"></label><input id="taskName" name="taskName" class="form-control mb-2" data-translate-placeholder-key="task_name_placeholder">
              
              <div class="mb-3">
                <label for="taskProject" class="form-label" data-translate-key="task_parent">Parent de la t√¢che</label>
                <select id="taskProject" name="taskProject" class="form-select">
                  <option value="" data-translate-key="select_project_option">S√©lectionner un projet</option>
                </select>
              </div>

              <div id="normalTaskFields">
                  <label for="taskStart"></label><input type="text" id="taskStart" name="taskStart" class="form-control mb-2" data-translate-placeholder-key="task_start_placeholder">
                  <label for="taskEnd"></label><input type="text" id="taskEnd" name="taskEnd" class="form-control mb-2" data-translate-placeholder-key="task_end_placeholder">
                  <label for="taskDuration"></label><input type="number" id="taskDuration" name="taskDuration" class="form-control mb-2" data-translate-placeholder-key="task_duration_placeholder">
                  <label for="taskProgress"></label><select id="taskProgress" name="taskProgress" class="form-select mb-2">
                    <option value="0">0%</option> <option value="0.1">10%</option> <option value="0.25">25%</option>
                    <option value="0.5">50%</option> <option value="0.75">75%</option> <option value="0.9">90%</option>
                    <option value="1">100%</option>
                  </select>
                  <label for="taskPriority"></label><select id="taskPriority" name="taskPriority" class="form-select mb-2">
                    <option value="project" data-translate-key="task_priority_project">Par d√©faut (Projet)</option>
                    <option value="low" data-translate-key="priority_low">üü¢ Basse</option>
                    <option value="medium" data-translate-key="priority_medium">üü° Moyenne</option>
                    <option value="high" data-translate-key="priority_high">üî¥ Haute</option>
                  </select>
                  <label class="form-label" data-translate-key="assigned_members_label">Membres assign√©s :</label>
                  <div id="taskMembers" class="mb-2" style="max-height: 120px; overflow-y: auto; border: 1px solid #e9ecef; padding: 10px; border-radius: 10px;"></div>
              </div>
              <div id="summaryTaskFields" style="display: none;">
              </div>

              <button class="btn btn-warning w-100" onclick="addTask()" data-translate-key="add_task_btn">Ajouter T√¢che</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="main">
    <div class="gantt-container">
      <div class="gantt-controls">
        <button id="toggleSidebarBtn" class="btn btn-outline-secondary" onclick="toggleSidebar()"></button>
        <button id="toggleGridBtn" class="btn btn-outline-info" onclick="toggleGanttGrid()"></button>
        <button class="btn btn-outline-primary" onclick="ganttZoomIn()">üîç+</button>
        <button class="btn btn-outline-primary" onclick="ganttZoomOut()">üîç-</button>
        <button class="btn btn-outline-info" onclick="manualRecalculate()" data-translate-key="recalculate_btn">üîÑ Recalculer</button>
        <button class="btn btn-outline-success" onclick="exportGanttToPNG()" data-translate-key="export_png_btn">üñºÔ∏è PNG</button>
        <button class="btn btn-outline-warning" onclick="undoLastAction()" data-translate-key="undo_btn" id="undoButton" disabled>‚Ü© Annuler</button>
      </div>
      <div id="gantt_here"></div>
    </div>
  </div>

  <div class="modal fade" id="editTaskMembersModal" tabindex="-1" aria-labelledby="editTaskMembersModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="editTaskMembersModalLabel" data-translate-key="manage_task_members_modal_title_prefix">G√©rer les membres de la t√¢che</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <input type="hidden" id="editTaskId" name="editTaskId">
          <label class="form-label" data-translate-key="assigned_members_label">Membres assign√©s :</label>
          <div id="editTaskMembersList" class="mb-2" style="max-height: 200px; overflow-y: auto; border: 1px solid #e9ecef; padding: 10px; border-radius: 10px;"></div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" aria-label="Close"></button>
          <button type="button" class="btn btn-primary" onclick="saveTaskMembers()" data-translate-key="save_btn">Sauvegarder</button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal fade" id="customTaskModal" tabindex="-1" aria-labelledby="customTaskModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="customTaskModalLabel" data-translate-key="custom_lightbox_title">Modifier la T√¢che</h5>
          <button type="button" class="btn-close" onclick="closeCustomLightbox()" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <input type="hidden" id="customLightboxTaskId" name="customLightboxTaskId">
          <div class="mb-3">
            <label for="customLightboxTaskName" class="form-label" data-translate-key="custom_lightbox_task_name_label">Nom</label>
            <input type="text" class="form-control" id="customLightboxTaskName" name="customLightboxTaskName" data-translate-placeholder-key="task_name_placeholder">
          </div>

          <div class="mb-3">
              <label for="customLightboxTaskType" class="form-label" data-translate-key="task_type_label">Type</label>
              <select id="customLightboxTaskType" name="customLightboxTaskType" class="form-select mb-2" onchange="toggleCustomLightboxFieldsVisibility()">
                  <option value="task" data-translate-key="task_type_normal">T√¢che normale</option>
                  <option value="project" data-translate-key="task_type_mother">T√¢che m√®re (Groupe)</option>
              </select>
          </div>

          <div class="mb-3">
              <label for="customLightboxTaskParent" class="form-label" data-translate-key="task_parent">Parent</label>
              <select class="form-select" id="customLightboxTaskParent">
                <option value="" data-translate-key="no_parent">Pas de parent</option>
              </select>
          </div>
          
          <div id="customLightboxProjectFields" style="display: none;">
              <div class="mb-3">
                  <label for="customLightboxProjectDescription" class="form-label" data-translate-key="project_description_placeholder">Description</label>
                  <textarea class="form-control" id="customLightboxProjectDescription" rows="2"></textarea>
              </div>
              <div class="row">
                  <div class="col-md-6 mb-3">
                      <label for="customLightboxProjectStart" class="form-label" data-translate-key="custom_lightbox_task_start_label">Date de d√©but</label>
                      <input type="text" class="form-control" id="customLightboxProjectStart">
                  </div>
                  <div class="col-md-6 mb-3">
                      <label for="customLightboxProjectEnd" class="form-label" data-translate-key="custom_lightbox_task_end_label">Date de fin</label>
                      <input type="text" class="form-control" id="customLightboxProjectEnd">
                  </div>
              </div>
              <div class="row">
                  <div class="col-md-6 mb-3">
                      <label for="customLightboxProjectColor" class="form-label" data-translate-key="custom_lightbox_task_color_label">Couleur</label>
                      <input type="color" class="form-control form-control-color w-100" id="customLightboxProjectColor" value="#667eea">
                  </div>
                  <div class="col-md-6 mb-3">
                      <label for="customLightboxProjectPriority" class="form-label" data-translate-key="custom_lightbox_task_priority_label">Priorit√©</label>
                      <select id="customLightboxProjectPriority" class="form-select">
                          <option value="low" data-translate-key="priority_low">üü¢ Basse</option>
                          <option value="medium" data-translate-key="priority_medium">üü° Moyenne</option>
                          <option value="high" data-translate-key="priority_high">üî¥ Haute</option>
                      </select>
                  </div>
              </div>
          </div>

          <div id="customLightboxNormalTaskFields">
              <div class="row">
                <div class="col-md-6 mb-3">
                  <label for="customLightboxTaskPriority" class="form-label" data-translate-key="custom_lightbox_task_priority_label">Priorit√©</label>
                  <select id="customLightboxTaskPriority" name="customLightboxTaskPriority" class="form-select">
                    <option value="project" data-translate-key="task_priority_project">Par d√©faut (Projet)</option>
                    <option value="low" data-translate-key="priority_low">üü¢ Basse</option>
                    <option value="medium" data-translate-key="priority_medium">üü° Moyenne</option>
                    <option value="high" data-translate-key="priority_high">üî¥ Haute</option>
                  </select>
                </div>
                <div class="col-md-6 mb-3">
                  <label for="customLightboxTaskProgress" class="form-label" data-translate-key="custom_lightbox_task_progress_label">Avancement</label>
                  <select id="customLightboxTaskProgress" name="customLightboxTaskProgress" class="form-select">
                    <option value="0">0%</option>
                    <option value="0.1">10%</option>
                    <option value="0.2">20%</option>
                    <option value="0.25">25%</option>
                    <option value="0.3">30%</option>
                    <option value="0.4">40%</option>
                    <option value="0.5">50%</option>
                    <option value="0.6">60%</option>
                    <option value="0.7">70%</option>
                    <option value="0.75">75%</option>
                    <option value="0.8">80%</option>
                    <option value="0.9">90%</option>
                    <option value="1">100%</option>
                  </select>
                </div>
              </div>

              <div class="row">
                <div class="col-md-4 mb-3">
                  <label for="customLightboxTaskStart" class="form-label" data-translate-key="custom_lightbox_task_start_label">Date de d√©but</label>
                  <input type="text" class="form-control" id="customLightboxTaskStart" name="customLightboxTaskStart">
                </div>
                <div class="col-md-4 mb-3">
                  <label for="customLightboxTaskEnd" class="form-label" data-translate-key="custom_lightbox_task_end_label">Date de fin</label>
                  <input type="text" class="form-control" id="customLightboxTaskEnd" name="customLightboxTaskEnd">
                </div>
                <div class="col-md-4 mb-3">
                  <label for="customLightboxTaskDuration" class="form-label" data-translate-key="custom_lightbox_task_duration_label">Dur√©e (jours)</label>
                  <input type="number" class="form-control" id="customLightboxTaskDuration" name="customLightboxTaskDuration" min="0" data-translate-placeholder-key="task_duration_placeholder">
                </div>
              </div>

              <div class="mb-3">
                <label for="customLightboxTaskColor" class="form-label" data-translate-key="custom_lightbox_task_color_label">Couleur de la t√¢che</label>
                <input type="color" class="form-control form-control-color" id="customLightboxTaskColor" name="customLightboxTaskColor" value="#5cb85c">
              </div>

              <div class="mb-3">
                <label class="form-label" data-translate-key="assigned_members_label">Membres assign√©s :</label>
                <div id="customLightboxTaskMembers" class="custom-lightbox-members-list"></div>
              </div>

              <div class="mb-3">
                <label for="customLightboxTaskComments" class="form-label" data-translate-key="custom_lightbox_task_comments_label">Commentaires</label>
                <textarea class="form-control" id="customLightboxTaskComments" name="customLightboxTaskComments" rows="3" data-translate-placeholder-key="task_comments_placeholder"></textarea>
              </div>
          </div>
          <div id="customLightboxSummaryTaskFields" style="display: none;">
              <p class="text-muted" data-translate-key="mother_task_note"></p>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-danger me-auto" onclick="deleteTaskFromCustomLightbox()" data-translate-key="delete_btn">Supprimer</button>
          <button type="button" class="btn btn-secondary" onclick="closeCustomLightbox()" data-translate-key="cancel_btn">Annuler</button>
          <button type="button" class="btn btn-primary" onclick="saveCustomLightboxChanges()" data-translate-key="save_btn">Sauvegarder</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script src="https://npmcdn.com/flatpickr/dist/l10n/fr.js"></script>
  <script src="https://npmcdn.com/flatpickr/dist/l10n/es.js"></script>
  <script src="https://npmcdn.com/flatpickr/dist/l10n/de.js"></script>
  <script src="https://npmcdn.com/flatpickr/dist/l10n/it.js"></script>
  <script>
    // Global variables
    let members = [];
    let projects = {};
    let allLinks = [];
    let currentLang = 'fr';
    let customTaskModalInstance = null;
    let currentEditingTaskId = null;
    let elementToFocusOnModalClose = null;
    let datePickers = [];
    let isSidebarCollapsed = false;
    let isGridVisible = true;
    let isUpdatingGanttProgrammatically = false; // Flag to prevent re-entry into event handlers
    let memberWorkload = {}; // Pour stocker la charge de travail par membre et par jour
    let highlightedInfo = { taskIds: [], level: '' };

    const historyStack = [];
    const MAX_HISTORY_SIZE = 10;

    const zoomLevels = [
        { name: "day", scale_unit: "day", date_scale: "%d %M", subscales: [{ unit: "hour", step: 6, date: "%Hh" }], min_column_width: 30 },
        { name: "week", scale_unit: "week", date_scale: "Semaine #%W", subscales: [{ unit: "day", step: 1, date: "%D %d", css: weekendCss }], min_column_width: 70 },
        { name: "month", scale_unit: "month", date_scale: "%F %Y", subscales: [{ unit: "week", step: 1, date: "Sem #%W" }], min_column_width: 90 },
        { 
            name: "quarter", 
            scale_unit: "quarter", 
            template: function(date) {
                return `${date.getFullYear()}, T${Math.ceil((date.getMonth() + 1) / 3)}`;
            },
            subscales: [{ unit: "month", step: 1, date: "%M" }],
            min_column_width: 90 
        },
        { 
            name: "year", 
            scale_unit: "year", 
            date_scale: "%Y", 
            subscales: [{ 
                unit: "quarter", 
                step: 1, 
                template: function(date) {
                    return "T" + Math.ceil((date.getMonth() + 1) / 3);
                }
            }],
            min_column_width: 50 
        }
    ];
    let currentZoomLevelIndex = 2;

    const translations = {
    fr: {
        export: "üíæ Exporter", import: "üìÇ Importer", clear_all_data_btn: "üóëÔ∏è Vider tout",
        clear_all_data_confirm: "√ätes-vous s√ªr de vouloir vider TOUTES les donn√©es (membres, projets, t√¢ches, liens) ? Cette action est irr√©versible.",
        clear_all_data_confirm_project: "√ätes-vous s√ªr de vouloir supprimer le projet '{name}' et toutes ses t√¢ches ? Cette action est irr√©versible.",
        clear_all_data_confirm_task: "√ätes-vous s√ªr de vouloir supprimer la t√¢che '{name}' ? Cette action est irr√©versible.",
        notification_all_data_cleared: "‚úÖ Toutes les donn√©es ont √©t√© effac√©es.", members_section_title: "üë• Membres",
        member_name_placeholder: "Nom du membre", add_member_btn: "Ajouter Membre", edit_member_btn: "Modifier Membre",
        projects_section_title: "üìÅ Projets", project_name_placeholder: "Nom du projet", project_description_placeholder: "Description",
        project_deadline_label: "√âch√©ance",
        priority_low: "üü¢ Basse", priority_medium: "üü° Moyenne", priority_high: "üî¥ Haute", create_project_btn: "Cr√©er Projet",
        new_task_section_title: "‚úÖ Nouvelle T√¢che", select_project_option: "S√©lectionner un projet", task_parent: "Parent de la t√¢che",
        no_parent: "Pas de parent", task_name_placeholder: "Nom de la t√¢che", task_end_placeholder: "Date de fin",
        task_duration_placeholder: "Dur√©e (jours ouvr√©s)", assigned_members_label: "Membres assign√©s :", add_task_btn: "Ajouter T√¢che",
        recalculate_btn: "üîÑ Recalculer", export_png_btn: "üñºÔ∏è PNG", undo_btn: "‚Ü© Annuler", hide_names_btn: "Masquer les noms",
        show_names_btn: "Afficher les noms", hide_sidebar_btn: "Masquer le menu", show_sidebar_btn: "Montrer le menu",
        toggle_overload_on: "Masquer Surcharges", toggle_overload_off: "Afficher Surcharges",
        edit_project_modal_title: "Modifier Projet", cancel_btn: "Annuler", save_btn: "Enregistrer", delete_btn: "Supprimer",
        manage_task_members_modal_title_prefix: "G√©rer les membres de la t√¢che", notification_export_success: "‚úÖ Donn√©es export√©es en JSON.",
        notification_import_success: "‚úÖ Donn√©es import√©es avec succ√®s.", notification_import_error: "‚ö†Ô∏è Erreur importation: ",
        notification_invalid_json_format: "Format JSON invalide ou donn√©es/compteurs manquants.", notification_member_added: "‚úÖ Membre {name} ajout√©.",
        notification_member_edited: "‚úÖ Membre {name} modifi√©.", notification_member_exists: "‚ö†Ô∏è Ce membre existe d√©j√†.",
        notification_enter_name: "‚ö†Ô∏è Entrez un nom.", notification_member_removed: "‚ùå Membre {name} supprim√©.",
        notification_visibility_updated: "‚úÖ Visibilit√© de {name} mise √† jour.", notification_no_members: "<small class=\"text-muted\">Aucun membre</small>",
        notification_project_name_required: "‚ö†Ô∏è Nom de projet requis.", notification_project_exists: "‚ö†Ô∏è Ce nom de projet existe d√©j√†.",
        notification_project_created: "üéâ Projet {name} cr√©√© avec t√¢ches par d√©faut.", notification_project_edited: "‚úÖ Projet {name} modifi√©.",
        notification_project_removed: "‚ùå Projet {name} supprim√©.", notification_fill_all_fields: "‚ö†Ô∏è Remplissez tous les champs (nom, d√©but, dur√©e > 0).",
        notification_invalid_project: "‚ö†Ô∏è Projet s√©lectionn√© invalide.", notification_task_added: "‚úÖ T√¢che {name} ajout√©e.",
        notification_task_members_updated: "‚úÖ Membres de la t√¢che {name} mis √† jour.", notification_task_updated: "‚úÖ T√¢che {name} mise √† jour.",
        notification_project_and_tasks_updated: "‚úÖ Projet {name} et ses t√¢ches mises √† jour.", notification_link_added: "üîó Lien ajout√©.",
        notification_link_removed: "‚ùå Lien supprim√©.", notification_task_deleted: "üóëÔ∏è T√¢che {name} supprim√©e.",
        notification_recalculated: "üîÑ Planning recalcul√© selon les d√©pendances", notification_recalculation_error: "‚ö†Ô∏è Erreur lors du recalcul",
        notification_png_exported: "üñºÔ∏è Diagramme export√© en PNG.", notification_no_tasks_to_export: "Aucune t√¢che √† exporter.",
        notification_invalid_date_format: "‚ö†Ô∏è Format de date invalide fourni.", notification_date_parse_error: "‚ö†Ô∏è Erreur lors de l'analyse de la date.",
        notification_task_reordered: "‚úÖ Ordre de la t√¢che {name} mis √† jour.", notification_drag_parent_restricted: "‚ö†Ô∏è Les t√¢ches ne peuvent √™tre d√©plac√©es que dans des projets ou devenir des t√¢ches de niveau sup√©rieur.",
        gantt_col_task: "T√¢che", gantt_col_start_date: "D√©but", gantt_col_end_date: "Fin", gantt_col_duration: "Dur√©e (j)",
        gantt_col_progress: "Avancement", gantt_col_members: "Membres", gantt_col_no_members: "Aucun", custom_lightbox_title: "Modifier la T√¢che/Projet",
        custom_lightbox_task_name_label: "Nom", custom_lightbox_task_priority_label: "Priorit√©", custom_lightbox_task_progress_label: "Avancement",
        custom_lightbox_task_start_label: "Date de d√©but", custom_lightbox_task_end_label: "Date de fin", custom_lightbox_task_duration_label: "Dur√©e (jours)",
        custom_lightbox_task_comments_label: "Commentaires", custom_lightbox_task_color_label: "Couleur", task_comments_placeholder: "Ajouter un commentaire...",
        task_priority_project: "Par d√©faut (Projet)", default_task_cahier_des_charges: "R√©alisation du cahier des charges ({projectName})",
        default_task_conception_pedagogique: "Conception p√©dagogique ({projectName})", default_task_production_contenus: "Production de contenus ({projectName})",
        default_task_developpement_interactif: "D√©veloppement interactif ({projectName})", default_task_tests_validation: "Tests et validation ({projectName})",
        gantt_week_prefix: "Sem.", task_start_placeholder: "Date de d√©but", task_type_label: "Type", task_type_normal: "T√¢che normale",
        task_type_mother: "T√¢che m√®re (Groupe)", mother_task_note: "Les d√©tails d'une t√¢che m√®re/projet sont calcul√©s √† partir de ses sous-t√¢ches. Vous pouvez modifier ses propri√©t√©s sp√©cifiques ici.",
        mother_task_creation_note: "Une t√¢che m√®re sert √† regrouper d'autres t√¢ches. Si elle est de niveau sup√©rieur, elle fonctionne comme un projet. Ses d√©tails (date de d√©but, fin, dur√©e, avancement, membres) seront calcul√©s automatiquement ou h√©rit√©s de ses sous-t√¢ches une fois celles-ci ajout√©es. Pour modifier les propri√©t√©s sp√©cifiques d'un projet de niveau sup√©rieur (couleur, priorit√†, description), utilisez la section \"Projets\" apr√®s sa cr√©ation.",
        validation_mother_task_parent_required: "‚ö†Ô∏è Une t√¢che m√®re doit avoir un projet ou une autre t√¢che m√®re comme parent."
    },
    en: {
        export: "üíæ Export", import: "üìÇ Import", clear_all_data_btn: "üóëÔ∏è Clear All",
        clear_all_data_confirm: "Are you sure you want to clear ALL data (members, projects, tasks, links)? This action is irreversible.",
        clear_all_data_confirm_project: "Are you sure you want to delete project '{name}' and all its tasks? This action is irreversible.",
        clear_all_data_confirm_task: "Are you sure you want to delete task '{name}'? This action is irreversible.",
        notification_all_data_cleared: "‚úÖ All data has been cleared.", members_section_title: "üë• Members",
        member_name_placeholder: "Member name", add_member_btn: "Add Member", edit_member_btn: "Edit Member",
        projects_section_title: "üìÅ Projects", project_name_placeholder: "Project name", project_description_placeholder: "Description",
        project_deadline_label: "Deadline",
        priority_low: "üü¢ Low", priority_medium: "üü° Medium", priority_high: "üî¥ High", create_project_btn: "Create Project",
        new_task_section_title: "‚úÖ New Task", select_project_option: "Select a project", task_parent: "Task parent",
        no_parent: "No parent", task_name_placeholder: "Task name", task_end_placeholder: "End date",
        task_duration_placeholder: "Duration (workdays)", assigned_members_label: "Assigned members:", add_task_btn: "Add Task",
        recalculate_btn: "üîÑ Recalculate", export_png_btn: "üñºÔ∏è PNG", undo_btn: "‚Ü© Undo", hide_names_btn: "Hide Names",
        show_names_btn: "Show Names", hide_sidebar_btn: "Hide menu", show_sidebar_btn: "Show menu",
        toggle_overload_on: "Hide Overload", toggle_overload_off: "Show Overload",
        edit_project_modal_title: "Edit Project", cancel_btn: "Cancel", save_btn: "Save", delete_btn: "Delete",
        manage_task_members_modal_title_prefix: "Manage task members", notification_export_success: "‚úÖ Data exported to JSON.",
        notification_import_success: "‚úÖ Data imported successfully.", notification_import_error: "‚ö†Ô∏è Import error: ",
        notification_invalid_json_format: "Invalid JSON format or missing data/counters.", notification_member_added: "‚úÖ Member {name} added.",
        notification_member_edited: "‚úÖ Member {name} updated.", notification_member_exists: "‚ö†Ô∏è This member already exists.",
        notification_enter_name: "‚ö†Ô∏è Enter a name.", notification_member_removed: "‚ùå Member {name} removed.",
        notification_visibility_updated: "‚úÖ Visibility of {name} updated.", notification_no_members: "<small class=\"text-muted\">No members</small>",
        notification_project_name_required: "‚ö†Ô∏è Project name required.", notification_project_exists: "‚ö†Ô∏è This project name already exists.",
        notification_project_created: "üéâ Project {name} created with default tasks.", notification_project_edited: "‚úÖ Project {name} updated.",
        notification_project_removed: "‚ùå Project {name} removed.", notification_fill_all_fields: "‚ö†Ô∏è Fill all fields (name, start, duration > 0).",
        notification_invalid_project: "‚ö†Ô∏è Invalid project selected.", notification_task_added: "‚úÖ T√¢che {name} ajout√©e.",
        notification_task_members_updated: "‚úÖ Task {name} members updated.", notification_task_updated: "‚úÖ T√¢che {name} mise √† jour.",
        notification_project_and_tasks_updated: "‚úÖ Projet {name} et ses t√¢ches mises √† jour.", notification_link_added: "üîó Link added.",
        notification_link_removed: "‚ùå Link removed.", notification_task_deleted: "üóëÔ∏è Task {name} deleted.",
        notification_recalculated: "üîÑ Schedule recalculated based on dependencies", notification_recalculation_error: "‚ö†Ô∏è Error during recalculation",
        notification_png_exported: "üñºÔ∏è Chart exported to PNG.", notification_no_tasks_to_export: "No tasks to export.",
        notification_invalid_date_format: "‚ö†Ô∏è Invalid date format provided.", notification_date_parse_error: "‚ö†Ô∏è Error parsing date.",
        notification_task_reordered: "‚úÖ Task {name} order updated.", notification_drag_parent_restricted: "‚ö†Ô∏è Tasks can only be moved within projects or become top-level tasks.",
        gantt_col_task: "Task", gantt_col_start_date: "Start", gantt_col_end_date: "End", gantt_col_duration: "Duration (d)",
        gantt_col_progress: "Progress", gantt_col_members: "Members", gantt_col_no_members: "None", custom_lightbox_title: "Edit Task/Project",
        custom_lightbox_task_name_label: "Name", custom_lightbox_task_priority_label: "Priority", custom_lightbox_task_progress_label: "Progress",
        custom_lightbox_task_start_label: "Start date", custom_lightbox_task_end_label: "End date", custom_lightbox_task_duration_label: "Duration (days)",
        custom_lightbox_task_comments_label: "Comments", custom_lightbox_task_color_label: "Color", task_comments_placeholder: "Add a comment...",
        task_priority_project: "Default (Project)", default_task_cahier_des_charges: "Specifications ({projectName})",
        default_task_conception_pedagogique: "Instructional Design ({projectName})", default_task_production_contenus: "Content Production ({projectName})",
        default_task_developpement_interactif: "Interactive Development ({projectName})", default_task_tests_validation: "Testing and Validation ({projectName})",
        gantt_week_prefix: "W", task_start_placeholder: "Start date", task_type_label: "Type", task_type_normal: "Normal task",
        task_type_mother: "Mother Task (Group)", mother_task_note: "Details for a mother task/project are calculated from its sub-tasks. You can edit its specific properties here.",
        mother_task_creation_note: "A mother task is used to group other tasks. If it is top-level, it functions as a project. Its details (start date, end, duration, progress, members) will be automatically calculated or inherited from its sub-tasks once added. To modify specific properties of a top-level project (color, priority, description), use the 'Projects' section after creation.",
        validation_mother_task_parent_required: "‚ö†Ô∏è A mother task must have a project or another mother task as a parent."
    },
    // ... other languages
    };

    function applyZoom(levelIndex) {
        if (levelIndex >= 0 && levelIndex < zoomLevels.length) {
            currentZoomLevelIndex = levelIndex;
            const newZoom = zoomLevels[currentZoomLevelIndex];
            gantt.config.scale_unit = newZoom.scale_unit;
            if (newZoom.template) {
                gantt.config.date_scale = null;
                gantt.templates.date_scale = newZoom.template;
            } else {
                gantt.config.date_scale = newZoom.date_scale;
                gantt.templates.date_scale = null; // Reset to default
            }
            gantt.config.subscales = newZoom.subscales;
            gantt.config.min_column_width = newZoom.min_column_width;
            gantt.render();
        }
    }

    function ganttZoomIn() {
        if (currentZoomLevelIndex > 0) {
            applyZoom(currentZoomLevelIndex - 1);
        }
    }

    function ganttZoomOut() {
        if (currentZoomLevelIndex < zoomLevels.length - 1) {
            applyZoom(currentZoomLevelIndex + 1);
        }
    }

    function translate(key, params = {}) {
        let translation = translations[currentLang]?.[key] || translations.fr[key] || key;
        for (const param in params) {
            translation = translation.replace(`{${param}}`, params[param]);
        }
        return translation;
    }

    function showNotification(message, type = 'success', params = {}, persistent = false) {
        const translatedMessage = message.startsWith("notification_") ? translate(message, params) : message;
        const div = document.createElement('div');
        div.className = `notification ${type}`;
        if (type === 'warning' || type === 'error') {
            div.classList.add('overload-alert');
        }
        div.innerHTML = translatedMessage;

        if (persistent) {
            const closeBtn = document.createElement('span');
            closeBtn.className = 'close-btn';
            closeBtn.innerHTML = '&times;';
            closeBtn.onclick = () => div.remove();
            div.appendChild(closeBtn);
        } else {
            setTimeout(() => div.remove(), 4000);
        }

        let container = document.querySelector('.notification-stack');
        if (!container) {
            container = document.createElement('div');
            container.className = 'notification-stack';
            document.body.appendChild(container);
        }
        container.appendChild(div);
    }

    function getFlatpickrDateFormatForLocale(lang) {
        switch (lang) {
            case 'fr': case 'es': case 'it': return "d/m/Y";
            case 'de': return "d.m.Y";
            default: return "Y-m-d";
        }
    }
    
    function getGanttDateFormatForLocale(lang) {
        switch (lang) {
            case 'fr': case 'es': case 'it': return "%d/%m/%Y";
            case 'de': return "%d.%m/%Y";
            default: return "%Y-%m-%d";
        }
    }

    function setupDatePickers() {
        if (datePickers.length > 0) {
            datePickers.forEach(picker => picker.destroy());
            datePickers = [];
        }
        const locale = (currentLang === 'en') ? 'default' : currentLang;
        const dateFormat = getFlatpickrDateFormatForLocale(currentLang);
        const pickerConfigs = ["#taskStart", "#taskEnd", "#customLightboxTaskStart", "#customLightboxTaskEnd", "#projectDeadline", "#customLightboxProjectStart", "#customLightboxProjectEnd"];
        pickerConfigs.forEach(selector => {
            const element = document.querySelector(selector);
            if (element) {
                const config = { dateFormat: dateFormat, locale: locale };
                if (selector === "#taskStart") {
                    config.onChange = function(selectedDates, dateStr, instance) {
                        if (selectedDates.length > 0) {
                            const endDatePicker = datePickers.find(p => p.element.id === 'taskEnd');
                            const durationInput = document.getElementById('taskDuration');
                            if (endDatePicker && endDatePicker.selectedDates.length > 0) {
                                const duration = gantt.calculateDuration({start_date: selectedDates[0], end_date: endDatePicker.selectedDates[0]});
                                durationInput.value = duration;
                            } else if (durationInput.value > 0) {
                                const endDate = gantt.calculateEndDate({start_date: selectedDates[0], duration: parseInt(durationInput.value)});
                                endDatePicker.setDate(endDate, false);
                            }
                        }
                    };
                } else if (selector === "#taskEnd") {
                    config.onChange = function(selectedDates, dateStr, instance) {
                        if (selectedDates.length > 0) {
                            const startDatePicker = datePickers.find(p => p.element.id === 'taskStart');
                            const durationInput = document.getElementById('taskDuration');
                            if (startDatePicker && startDatePicker.selectedDates.length > 0) {
                                const duration = gantt.calculateDuration({start_date: startDatePicker.selectedDates[0], end_date: selectedDates[0]});
                                durationInput.value = duration;
                            }
                        }
                    };
                } else if (selector === "#customLightboxTaskStart") {
                    config.onChange = function() { updateLightboxSchedule('start'); };
                } else if (selector === "#customLightboxTaskEnd") {
                    config.onChange = function() { updateLightboxSchedule('end'); };
                }
                datePickers.push(flatpickr(element, config));
            }
        });
        const taskDurationInput = document.getElementById('taskDuration');
        if (taskDurationInput) {
            taskDurationInput.removeEventListener('input', updateTaskDurationFromInput);
            taskDurationInput.addEventListener('input', updateTaskDurationFromInput);
        }
    }

    function updateTaskDurationFromInput() {
        const taskStartPicker = datePickers.find(p => p.element.id === 'taskStart');
        const taskEndPicker = datePickers.find(p => p.element.id === 'taskEnd');
        const durationValue = parseInt(document.getElementById('taskDuration').value);
        if (taskStartPicker && taskStartPicker.selectedDates.length > 0 && !isNaN(durationValue) && durationValue >= 0) {
            const startDate = taskStartPicker.selectedDates[0];
            const endDate = gantt.calculateEndDate({start_date: startDate, duration: durationValue});
            if (taskEndPicker) taskEndPicker.setDate(endDate, false);
        }
    }

    function applyTranslations() {
        document.documentElement.lang = currentLang;
        if (gantt && gantt.i18n) {
           try {
             gantt.i18n.setLocale(currentLang);
           } catch (e) {
             console.warn("DHTMLX locale for " + currentLang + " not fully available, falling back. Erreur: " + e.message);
             if (currentLang !== 'en') {
                try { gantt.i18n.setLocale('en'); } catch (e2) {}
             }
           }
        }
        document.querySelectorAll('[data-translate-key]').forEach(el => {
            const key = el.dataset.translateKey;
            const isLabel = el.tagName === 'LABEL';
            if (isLabel) {
              el.innerHTML = translate(key);
            } else {
              el.textContent = translate(key);
            }
        });
        document.querySelectorAll('[data-translate-placeholder-key]').forEach(el => {
            el.placeholder = translate(el.dataset.translatePlaceholderKey);
        });
        const memberActionBtn = document.getElementById('memberActionBtn');
        if (memberActionBtn) {
            memberActionBtn.textContent = translate(document.getElementById('editMemberId').value ? 'edit_member_btn' : 'add_member_btn');
        }
        const taskProjectSelect = document.getElementById('taskProject');
        if (taskProjectSelect) {
            const firstOption = taskProjectSelect.querySelector('option[value=""]');
            if (firstOption) firstOption.textContent = translate('select_project_option');
        }
        document.querySelectorAll('#projectPriority option, #customLightboxTaskPriority option, #taskPriority option, #customLightboxProjectPriority option').forEach(option => {
            if(option.value === 'project') {
              option.textContent = translate('task_priority_project');
            } else if (option.value) {
              const key = `priority_${option.value}`;
              option.textContent = translate(key);
            }
        });
        document.querySelectorAll('.language-selector button').forEach(button => {
            button.classList.remove('btn-primary', 'text-white');
            button.classList.add('btn-light');
        });
        const activeButton = document.querySelector(`.language-selector button[onclick="setLanguage('${currentLang}')"]`);
        if (activeButton) {
            activeButton.classList.remove('btn-light');
            activeButton.classList.add('btn-primary', 'text-white');
        }
        const toggleGridBtn = document.getElementById('toggleGridBtn');
        const gridBtnKey = isGridVisible ? 'hide_names_btn' : 'show_names_btn';
        toggleGridBtn.setAttribute('data-translate-key', gridBtnKey);
        toggleGridBtn.textContent = translate(gridBtnKey);
        const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
        const sidebarBtnKey = isSidebarCollapsed ? 'show_sidebar_btn' : 'hide_sidebar_btn';
        toggleSidebarBtn.setAttribute('data-translate-key', sidebarBtnKey);
        toggleSidebarBtn.textContent = translate(sidebarBtnKey);
        
        if (gantt && gantt.config) {
            if (gantt.locale.labels) {
                gantt.locale.labels.label_save = translate('save_btn');
                gantt.locale.labels.label_cancel = translate('cancel_btn');
                gantt.locale.labels.label_delete = translate('delete_btn');
            }
            gantt.config.columns = getGanttColumns();
        }
        renderMembers();
        renderProjects();
        updateTaskMembers();
        toggleNewTaskFieldsVisibility();
        updateUndoButtonState();
    }

    function setLanguage(lang) {
        currentLang = lang;
        setupDatePickers();
        applyTranslations();
        // No need to call updateGantt here, syncAndRenderGantt will be called after init
        // if(gantt && gantt.$container) {
        //     updateGantt();
        // }
    }

    function toggleSidebar() {
        const sidebar = document.querySelector('.sidebar');
        const btn = document.getElementById('toggleSidebarBtn');
        const transitionDuration = 350;
        if (!isSidebarCollapsed) {
            sidebar.classList.add('collapsed');
            btn.textContent = translate('show_sidebar_btn');
            setTimeout(() => {
                if(gantt) gantt.render();
            }, transitionDuration);
        } else {
            requestAnimationFrame(() => {
                sidebar.classList.remove('collapsed');
                btn.textContent = translate('hide_sidebar_btn');
                setTimeout(() => {
                    if(gantt) gantt.render();
                }, transitionDuration);
            });
        }
        isSidebarCollapsed = !isSidebarCollapsed;
    }

    function toggleGanttGrid() {
        isGridVisible = !isGridVisible;
        gantt.config.show_grid = isGridVisible;
        gantt.render();
        const btn = document.getElementById('toggleGridBtn');
        const key = isGridVisible ? 'hide_names_btn' : 'show_names_btn';
        btn.setAttribute('data-translate-key', key);
        btn.textContent = translate(key);
    }

    function weekendCss(date) {
      return (date.getDay() === 0 || date.getDay() === 6) ? "weekend" : "";
    }

    function getGanttColumns() {
        return [
            {
                name: "text", label: translate('gantt_col_task'), width: '*', tree: true, resize: true,
                template: function(task) {
                    const taskText = (task.text || '').replace(/^[üî¥üü°üü¢]\s*/, ''); 
                    if (task.type === gantt.config.types.milestone) {
                        return taskText;
                    }
                    if (task.type === gantt.config.types.project) {
                        const projectData = findTaskInProjectsModel(task.id);
                        // Ensure progress is a number, default to 0 if NaN/undefined
                        const progressValue = typeof projectData?.progress === 'number' ? projectData.progress : 0;
                        return `${taskText} (${Math.round(progressValue * 100)}%)`;
                    }
                    let taskName = taskText;
                    let memberDots = "";
                    let progressDisplay = "";
                    let taskDataInStore = findTaskInProjectsModel(task.id);
                    if (taskDataInStore) {
                        const memberIds = taskDataInStore.memberIds || [];
                        const visibleMembers = members.filter(m => m.visible).filter(member => memberIds.includes(String(member.id)));
                        if (visibleMembers.length > 0) {
                            memberDots = visibleMembers.map(member => `<span class="member-indicator" style="background-color:${member.color}; vertical-align: middle;" title="${(member.name || '')}"></span>`).join("");
                        }
                        // Ensure progress is a number, default to 0 if NaN/undefined
                        const progressValue = typeof taskDataInStore.progress === 'number' ? taskDataInStore.progress : 0;
                        progressDisplay = ` (${Math.round(progressValue * 100)}%)`;
                    } else {
                       // Fallback for tasks not found in model (shouldn't happen often)
                       const progressValue = typeof task.progress === 'number' ? task.progress : 0;
                       progressDisplay = ` (${Math.round(progressValue * 100)}%)`;
                    }
                    return `${taskName} ${memberDots} ${progressDisplay}`;
                }
            },
            {
                name: "lock", label: "‚úî", width: 40, align: "center",
                template: function(task) {
                    return `<div class="gantt_grid_cell_lock" onclick="toggleTaskLock('${task.id}')">${task.locked ? '‚òê' : '‚úÖ'}</div>`;
                }
            }
        ];
    }

    function findTaskInProjectsModel(taskId) {
        if (!taskId || String(taskId) === "0") return null;
        const targetId = String(taskId);
        
        // First, check if it's a top-level project/task directly
        if (projects[targetId]) {
            return projects[targetId];
        }

        let found = null;
        function search(tasks) {
            if (!tasks) return; 
            for (const task of tasks) {
                if (String(task.id) === targetId) {
                    found = task;
                    return;
                }
                if (task.tasks) {
                    search(task.tasks);
                    if (found) return;
                }
            }
        }
        // Then search recursively within all projects' tasks
        search(Object.values(projects));
        
        return found;
    }

    function populateProjectDropdown(selectElementId, selectedParentId = '', currentEditingId = null, includeAllSummaryTasks = true, allowNoParent = true) {
        const parentSelect = document.getElementById(selectElementId);
        if (!parentSelect) return;
        parentSelect.innerHTML = '';
        if (allowNoParent) {
            parentSelect.add(new Option(translate('no_parent'), "0"));
        }
        
        const allPotentialParents = [];

        // Function to recursively collect all tasks that can be parents
        function collectAllTasks(tasks, level = 0) {
            tasks.forEach(task => {
                // Only allow project/mother tasks to be parents
                if (task.type === gantt.config.types.project) {
                    allPotentialParents.push({ id: task.id, name: task.name, level: level, type: task.type });
                }
                if (task.tasks) {
                    collectAllTasks(task.tasks, level + 1);
                }
            });
        }
        
        // Start collecting from top-level projects
        collectAllTasks(Object.values(projects));

        // Filter and add options to the dropdown
        allPotentialParents.forEach(parent => {
            // Exclude the task being edited from being its own parent or a child of itself
            if (String(parent.id) === String(currentEditingId)) {
                return; // Skip the task itself
            }
            // Exclude tasks that are children of the current task being edited
            // This prevents creating circular dependencies
            if (currentEditingId && gantt.isChildOf(parent.id, currentEditingId)) {
                return; // Skip children of the current task
            }

            let prefix = "".padStart(parent.level * 4, '¬†'); // Use non-breaking space for indentation
            const optionText = prefix + parent.name + (parent.type === gantt.config.types.project ? ' (Groupe)' : ''); // Add (Group) for clarity
            const option = new Option(optionText, parent.id);
            parentSelect.add(option);
        });

        // Set the selected value
        parentSelect.value = selectedParentId || "0";
    }

    function recalculateProjectDatesAndProgress(taskId) {
        if (!gantt.isTaskExists(taskId)) {
            return;
        }
        const ganttTask = gantt.getTask(taskId);
        if (!ganttTask || ganttTask.type !== gantt.config.types.project) return;
        const taskDataStore = findTaskInProjectsModel(taskId);
        if (!taskDataStore) {
            return;
        }

        let totalWeightedProgress = 0; // Sum of (child duration * child progress)
        let totalChildrenDuration = 0; // Sum of all children durations
        let minStartDate = null;
        let maxEndDate = null;

        // Use gantt.getChildren to get direct children
        const childrenIds = gantt.getChildren(taskId);

        childrenIds.forEach(childId => {
            const child = gantt.getTask(childId);
            if (!child) return;

            // If the child is a project, recursively calculate its progress first
            if (child.type === gantt.config.types.project) {
                recalculateProjectDatesAndProgress(child.id); // Recurse for nested projects
                // After recursion, child.duration and child.progress in Gantt's internal state should be updated
            }

            // Now, use the (potentially updated) child's duration and progress
            // Only include non-milestone tasks for duration/progress calculation
            if (child.type !== gantt.config.types.milestone) {
                totalChildrenDuration += child.duration;
                totalWeightedProgress += child.duration * child.progress;
            }

            // Update min/max dates based on all children (including milestones and projects)
            if (child.start_date && (!minStartDate || child.start_date < minStartDate)) {
                minStartDate = child.start_date;
            }
            if (child.end_date && (!maxEndDate || child.end_date > maxEndDate)) {
                maxEndDate = child.end_date;
            }
        });

        // Calculate overall progress for the current project
        const calculatedProgress = totalChildrenDuration > 0 ? totalWeightedProgress / totalChildrenDuration : 0;
        
        // Calculate overall duration for the current project based on its children's min/max dates
        const calculatedDuration = (minStartDate && maxEndDate) ? gantt.calculateDuration({start_date: minStartDate, end_date: maxEndDate}) : 0;

        // Update the model with calculated values
        taskDataStore.start = minStartDate ? gantt.date.date_to_str(gantt.config.date_format)(minStartDate) : null;
        taskDataStore.end = maxEndDate ? gantt.date.date_to_str(gantt.config.date_format)(maxEndDate) : null;
        taskDataStore.duration = calculatedDuration;
        taskDataStore.progress = calculatedProgress; // Ensure this is always a number
        
        // Also update the Gantt task's internal state to reflect these calculated values
        // This is crucial for Gantt to display the correct summary
        ganttTask.start_date = minStartDate;
        ganttTask.end_date = maxEndDate;
        ganttTask.duration = calculatedDuration;
        ganttTask.progress = calculatedProgress;
        gantt.updateTask(taskId); // Update Gantt's internal state
    }

    function renderMembers() {
        const container = document.getElementById('membersList');
        if (!container) return;

        calculateMemberWorkload(); 

        container.innerHTML = members.length === 0 ? translate('notification_no_members') : members.map(m => {
            const memberOverload = getMemberOverload(m.id);
            let overloadHtml = '';
            if (memberOverload.length > 0) {
                overloadHtml = `
                    <div class="overload-dropdown">
                        <select class="form-select form-select-sm" onchange="highlightOverloadDay('${m.id}', this.value)">
                            <option value="">Jours en surcharge</option>
                            ${memberOverload.map(day => `<option value="${day.rawDate}">${day.icon} ${day.date}</option>`).join('')}
                        </select>
                    </div>`;
            }
            return `
                <div class="task-item">
                    <div class="member-item">
                        <div class="member-info">
                            <input type="checkbox" ${m.visible ? 'checked' : ''} onchange="toggleMemberVisibility('${m.id}')">
                            <span class="member-indicator" style="background-color: ${m.color};"></span> ${m.name}
                        </div>
                        <button class="btn btn-sm btn-outline-primary me-2" onclick="editMember('${m.id}')">‚úèÔ∏è</button>
                        <button class="btn btn-sm btn-outline-danger" onclick="removeMember('${m.id}')">üóëÔ∏è</button>
                        ${overloadHtml}
                    </div>
                </div>`;
        }).join('');
    }

    function renderProjects() {
      const list = document.getElementById('projectList'); const select = document.getElementById('taskProject');
      if (!list || !select) return;
      list.innerHTML = Object.values(projects).map(project => {
          let priorityEmoji = '';
          if (project.priority === "high") priorityEmoji = "üî¥ ";
          else if (project.priority === "medium") priorityEmoji = "üü° ";
          else if (project.priority === "low") priorityEmoji = "üü¢ ";
          return `
        <div class="task-item" style="border-left: 4px solid ${project.color};">
          <input type="checkbox" ${project.visible ? 'checked' : ''} onchange="toggleProjectVisibility('${project.id}')">
          <span class="member-indicator" style="background-color: ${project.color};"></span> ${priorityEmoji}${project.name} (${translate('priority_' + project.priority)})
          <button class="btn btn-sm btn-outline-primary me-2" onclick="openCustomLightbox('${project.id}')">‚úèÔ∏è</button>
          <button class="btn btn-sm btn-outline-danger" onclick="removeProject('${project.id}')">üóëÔ∏è</button>
        </div>`;
      }).join('');
    }

    function updateTaskMembers() {
      const container = document.getElementById('taskMembers');
      if (!container) return;
      container.innerHTML = members.length === 0 ? translate('notification_no_members') : members.map(m => `
        <div class="form-check">
          <input class="form-check-input" type="checkbox" value="${m.id}" id="task-member-${m.id}" name="task-member-${m.id}">
          <label class="form-check-label" for="task-member-${m.id}"> <span class="member-indicator" style="background-color: ${m.color};"></span> ${m.name} </label>
        </div>`).join('');
    }

    function toggleNewTaskFieldsVisibility() {
        const taskType = document.getElementById('taskType').value;
        const normalFields = document.getElementById('normalTaskFields');
        const summaryTaskNote = document.getElementById('summaryTaskNote');
        if (taskType === 'task') {
            normalFields.style.display = 'block';
            summaryTaskNote.style.display = 'none';
            populateProjectDropdown('taskProject', '', null, true, true); 
            document.getElementById('taskStart').setAttribute('required', 'required');
            document.getElementById('taskEnd').setAttribute('required', 'required');
            document.getElementById('taskDuration').setAttribute('required', 'required');
        } else {
            normalFields.style.display = 'none';
            summaryTaskNote.style.display = 'block';
            // For mother tasks, only allow existing projects/mother tasks as parents
            populateProjectDropdown('taskProject', '', null, true, false); 
            const taskProjectSelect = document.getElementById('taskProject');
            if (taskProjectSelect.options.length > 0 && taskProjectSelect.value === "") {
                // If no parent is selected and options exist, select the first one
                if (taskProjectSelect.options.length > 0) {
                     taskProjectSelect.selectedIndex = 0;
                }
            }
        }
    }

    function renderSidebars() {
      renderMembers();
      renderProjects();
      updateTaskMembers();
      toggleNewTaskFieldsVisibility();
    }

    function updateUndoButtonState() {
        const undoButton = document.getElementById('undoButton');
        if (undoButton) undoButton.disabled = historyStack.length <= 1; 
    }

    function memorizeCollapseState() {
	  collapsedStateMap = {};
	  gantt.eachTask(function (task) {
		if (task.type === "project") collapsedStateMap[task.id] = !task.$open;
	  });
	}

	function restoreCollapseState() {
	  gantt.eachTask(function (task) {
		if (collapsedStateMap[task.id] === true) gantt.close(task.id);
        else if (collapsedStateMap[task.id] === false) gantt.open(task.id);
	  });
	}

    // New function to centralize Gantt update and recalculation
    function syncAndRenderGantt() {
        isUpdatingGanttProgrammatically = true;
        updateGantt(); // This clears and re-parses from our 'projects' model
        manualRecalculate(true); // This re-schedules based on the newly parsed Gantt data
        isUpdatingGanttProgrammatically = false; // Reset flag after full cycle
        updateUndoButtonState(); // Update undo button state after all changes
    }

    function updateGantt() {
		if (!gantt || !gantt.$container) { return; }
        const scrollState = gantt.getScrollState();
		memorizeCollapseState(); 
		gantt.clearAll();
		const ganttDataTasks = [];

        // Recursive function to get all tasks and their children that should be displayed
        function getVisibleTasks(tasks, parentVisible) {
            tasks.forEach(item => {
                if (!item) return;

                const isProjectVisible = item.type === gantt.config.types.project ? item.visible : true;
                const shouldDisplay = parentVisible && isProjectVisible;

                if (shouldDisplay) {
                    // Convert start/end dates from string to Date objects for Gantt.parse
                    const startDateObj = item.start ? gantt.date.str_to_date(gantt.config.date_format)(item.start) : null;
                    const endDateObj = item.end ? gantt.date.str_to_date(gantt.config.date_format)(item.end) : null;

                    const ganttTask = {
                        id: item.id,
                        name: item.name,
                        text: item.name,
                        start_date: startDateObj,
                        end_date: endDateObj,
                        duration: item.duration,
                        progress: item.progress,
                        parent: item.parent,
                        type: item.type,
                        color: item.color,
                        locked: item.locked,
                        open: item.open,
                        // Add visible property to Gantt task for onBeforeTaskDisplay to use
                        visible: item.visible // This will be used for projects
                    };
                    ganttDataTasks.push(ganttTask);
                    console.log("[DEBUG] getVisibleTasks: Added Gantt task:", ganttTask.name, "(ID:", ganttTask.id, ", Parent:", ganttTask.parent, ", Type:", ganttTask.type, ")");
                } else {
                    console.log("[DEBUG] getVisibleTasks: Skipping invisible task:", item.name, "(ID:", item.id, ", Parent:", item.parent, ", Type:", item.type, ")");
                }

                if (item.tasks && item.tasks.length > 0) {
                    console.log("[DEBUG] getVisibleTasks: Processing children of", item.name);
                    getVisibleTasks(item.tasks, shouldDisplay); // Pass down parent's visibility
                }
            });
        }
        
        // Start collecting tasks from top-level projects, assuming they are initially visible
        console.log("[DEBUG] updateGantt: Starting collection of visible tasks from top-level projects.");
        getVisibleTasks(Object.values(projects), true);
		
		gantt.parse({ data: ganttDataTasks, links: allLinks });
		restoreCollapseState(); 
		
        // Recalculate project dates/progress after parsing, before rendering
		gantt.eachTask(function(task) {
			if (task.type === gantt.config.types.project) {
				recalculateProjectDatesAndProgress(task.id);
			}
		});
		gantt.render();
        if (scrollState) gantt.scrollTo(scrollState.x, scrollState.y);
		renderSidebars(); // Re-render sidebars to reflect any changes in members/projects lists
	}

    function manualRecalculate(isInternalCall = false) {
        if (!isInternalCall) saveStateToHistory();

        let changed = true;
        let iterations = 0;
        const maxIterations = gantt.getTaskCount() * 2; 

        const allGanttTasks = [];
        gantt.eachTask(function(task) {
            allGanttTasks.push(task);
        });

        allGanttTasks.sort((a, b) => a.start_date - b.start_date);

        while (changed && iterations < maxIterations) {
            changed = false;
            allGanttTasks.forEach(task => {
                if (task.type !== gantt.config.types.task || task.readonly) return;

                const predecessors = allLinks.filter(link => String(link.target) === String(task.id) && link.type === '0'); 
                if (predecessors.length === 0) return;

                let latestPredecessorEndDate = null;

                predecessors.forEach(link => {
                    const predecessorTask = gantt.getTask(link.source); 
                    if (predecessorTask && predecessorTask.end_date) {
                        if (!latestPredecessorEndDate || predecessorTask.end_date > latestPredecessorEndDate) {
                            latestPredecessorEndDate = predecessorTask.end_date;
                        }
                    }
                });

                if (latestPredecessorEndDate) {
                    let requiredStartDate = gantt.date.add(latestPredecessorEndDate, 1, 'day');
                    if (gantt.config.skip_off_time) {
                        while (!gantt.isWorkTime({ date: requiredStartDate, unit: "day" })) {
                            requiredStartDate = gantt.date.add(requiredStartDate, 1, 'day');
                        }
                    }
                    
                    const currentStartDate = task.start_date;

                    if (requiredStartDate > currentStartDate) {
                        task.start_date = requiredStartDate;
                        task.end_date = gantt.calculateEndDate({ start_date: task.start_date, duration: task.duration });
                        
                        const modelTask = findTaskInProjectsModel(task.id);
                        if (modelTask) {
                            modelTask.start = gantt.date.date_to_str(gantt.config.date_format)(task.start_date);
                            modelTask.end = gantt.date.date_to_str(gantt.config.date_format)(task.end_date);
                        }
                        gantt.updateTask(task.id); 
                        changed = true;
                    }
                }
            });
            iterations++;
        }

        gantt.eachTask(task => {
            if (task.type === gantt.config.types.project) {
                recalculateProjectDatesAndProgress(task.id);
            }
        });

        if (!isInternalCall) {
            syncAndRenderGantt(); 
            showNotification("notification_recalculated", 'success');
        }
    }

    function saveStateToHistory() {
        const currentState = {
            members: JSON.parse(JSON.stringify(members)),
            projects: JSON.parse(JSON.stringify(projects)),
            allLinks: JSON.parse(JSON.stringify(allLinks)),
        };
        historyStack.push(currentState);
        if (historyStack.length > MAX_HISTORY_SIZE) historyStack.shift();
        updateUndoButtonState();
    }

    function undoLastAction() {
        if (historyStack.length > 1) {
            historyStack.pop();
            const previousState = historyStack[historyStack.length - 1];
            members = previousState.members;
            projects = previousState.projects;
            allLinks = previousState.allLinks;
            syncAndRenderGantt(); // Call central sync function
            showNotification('Action annul√©e.');
        } else {
            showNotification('Impossible d\'annuler davantage.', 'error');
        }
    }

    function initGantt() {
      gantt.plugins({ 
          export_api: true, 
          zoom: true, 
          tooltip: true
          // auto_scheduling: true // Supprim√© car c'est une fonctionnalit√© PRO
      });
      gantt.config.work_time = true;
      gantt.config.skip_off_time = true;
      // gantt.config.auto_scheduling = true; // Supprim√©
      // gantt.config.auto_scheduling_strict = true; // Supprim√©
      // gantt.config.auto_scheduling_initial = true; // Supprim√©
      gantt.config.date_format = "%Y-%m-%d";
      gantt.config.grid_resize = true;
      gantt.config.drag_progress = true;
      gantt.config.tooltip_timeout = 30;
      gantt.config.show_grid = isGridVisible;
      gantt.config.order_branch = true;
      gantt.config.order_branch_free = true;
      gantt.config.auto_types = true;
      gantt.config.drag_project = false;
      gantt.setWorkTime({ day: 0, hours: false });
      gantt.setWorkTime({ day: 6, hours: false });
      gantt.templates.date_grid = function(date){
          let format;
          switch(currentLang) {
              case 'fr': case 'es': case 'it': format = "%d/%m/%Y"; break;
              case 'de': format = "%d.%m.%Y"; break;
              default: format = "%Y-%m-%d";
          }
          return gantt.date.date_to_str(format)(date);
      };
      gantt.config.columns = getGanttColumns();
      gantt.init("gantt_here");
      
      // --- EVENT HANDLERS ---

      gantt.attachEvent("onAfterTaskDrag", function(id, mode, e){
          if (isUpdatingGanttProgrammatically) {
              return;
          }
          saveStateToHistory(); // Save state *before* model modification
          
          const ganttTask = gantt.getTask(id);
          const taskInDataModel = findTaskInProjectsModel(id);
          if (!taskInDataModel) {
              showNotification(`Erreur critique: T√¢che non trouv√©e dans le mod√®le de donn√©es (ID: ${id}) apr√®s un glisser-d√©poser. Veuillez v√©rifier la console pour plus de d√©tails.`, 'error', {}, true);
              // console.error("CRITICAL ERROR: Task not found in data model after drag for ID:", id, "Gantt task:", JSON.parse(JSON.stringify(ganttTask)), "Current projects state:", JSON.parse(JSON.stringify(projects)));
              return;
          }


          const oldParentId = taskInDataModel.parent;
          const newParentId = String(ganttTask.parent);

          // Update the task in our data model
          taskInDataModel.start = gantt.date.date_to_str(gantt.config.date_format)(ganttTask.start_date);
          taskInDataModel.duration = ganttTask.duration;
          taskInDataModel.progress = ganttTask.progress;
          taskInDataModel.end = gantt.date.date_to_str(gantt.config.date_format)(ganttTask.end_date); // Sync end date too
          taskInDataModel.type = ganttTask.type; // Sync type if it changed (e.g., from task to project by drag)

          // Handle parent change in the model
          if (oldParentId !== newParentId) {
              let oldParentData = findTaskInProjectsModel(oldParentId);
              if (oldParentData && oldParentData.tasks) {
                  const index = oldParentData.tasks.findIndex(t => t.id === id);
                  if (index > -1) {
                      oldParentData.tasks.splice(index, 1);
                  }
              } else if (oldParentId === "0") { // Was a top-level project/task
                  delete projects[id];
              }

              let newParentData = findTaskInProjectsModel(newParentId);
              if (newParentData) {
                  if (!newParentData.tasks) {
                      newParentData.tasks = [];
                  }
                  newParentData.tasks.push(taskInDataModel);
              } else if (newParentId === "0") { // New parent is root (0), so it becomes a top-level project/task
                   projects[id] = taskInDataModel;
              } else {
                  showNotification(`Erreur: Nouveau parent (ID: ${newParentId}) non trouv√© pour la t√¢che ${id}. Veuillez v√©rifier la console.`, 'error', {}, true);
                  // console.error(`ERROR: New parent (ID: ${newParentId}) not found for task ${id}.`);
              }
              taskInDataModel.parent = newParentId;
          }
          
          syncAndRenderGantt(); // Call the central sync function
      });

      gantt.attachEvent("onBeforeRowDragEnd", function(id, parent, tindex) {
          if (parent == 0) return true;
          if (!gantt.isTaskExists(parent)) return false;
          const newParentTask = gantt.getTask(parent);
          if (newParentTask.type === 'task') {
              showNotification("Une t√¢che ne peut pas contenir d'autres t√¢ches.", "error");
              return false;
          }
          return true;
      });
      
      gantt.attachEvent("onAfterTaskUpdate", function(id, task){
          if (isUpdatingGanttProgrammatically) {
              return;
          }
          saveStateToHistory(); // Save state *before* model modification

          const taskInDataModel = findTaskInProjectsModel(id);
          if (!taskInDataModel) {
              showNotification(`Erreur critique: T√¢che non trouv√©e dans le mod√®le de donn√©es (ID: ${id}) apr√®s une mise √† jour. Veuillez v√©rifier la console pour plus de d√©tails.`, 'error', {}, true);
              // console.error("CRITICAL ERROR: Task not found in data model for ID:", id, "Gantt task:", JSON.parse(JSON.stringify(task)), "Current projects state:", JSON.parse(JSON.stringify(projects)));
              return;
          }

          // Update our data model with the changes from the Gantt task object
          taskInDataModel.name = task.text;
          taskInDataModel.text = task.text;
          taskInDataModel.start = gantt.date.date_to_str(gantt.config.date_format)(task.start_date);
          taskInDataModel.duration = task.duration;
          taskInDataModel.progress = task.progress;
          taskInDataModel.end = gantt.date.date_to_str(gantt.config.date_format)(task.end_date); // Sync end date too
          taskInDataModel.type = task.type; 
          taskInDataModel.parent = String(task.parent); // Ensure parent is string

          syncAndRenderGantt(); 
      });

      gantt.attachEvent("onAfterLinkAdd", function(id, link) {
        if (isUpdatingGanttProgrammatically) return;
        saveStateToHistory();
        const newLink = { id: crypto.randomUUID().toString(), source: String(link.source), target: String(link.target), type: String(link.type) };
        allLinks.push(newLink);
        gantt.changeLinkId(id, newLink.id); // Update Gantt's link ID to match our new UUID
        showNotification("notification_link_added");
        syncAndRenderGantt(); // Call the central sync function
        return true;
      });

      gantt.attachEvent("onAfterLinkDelete", function(id, link) {
        if (isUpdatingGanttProgrammatically) return;
        saveStateToHistory();
        allLinks = allLinks.filter(l => String(l.id) !== String(id));
        showNotification("notification_link_removed");
        syncAndRenderGantt(); // Call the central sync function
        return true;
      });
      
      gantt.attachEvent("onAfterTaskDelete", function(id, task) {
          if (isUpdatingGanttProgrammatically) return;
          saveStateToHistory();
          const parentId = String(task.parent);
          let parentModel = findTaskInProjectsModel(parentId);
          if (!parentModel) { // It was a top-level project/task
              delete projects[id];
          } else if (parentModel.tasks) {
              const index = parentModel.tasks.findIndex(t => t.id === id);
              if (index > -1) parentModel.tasks.splice(index, 1);
          }
          allLinks = allLinks.filter(l => String(l.source) !== String(id) && String(l.target) !== String(id));
          showNotification('notification_task_deleted', 'success', {name: (task.text || '').replace(/^[üî¥üü°üü¢]\s*/, '').trim()});
          syncAndRenderGantt(); // Call the central sync function
      });
      
      applyZoom(currentZoomLevelIndex);
      
      gantt.templates.task_text = function(start, end, task){
          const taskText = (task.text || '').replace(/^[üî¥üü°üü¢]\s*/, ''); 
          if (task.type === gantt.config.types.milestone) return taskText;
          // Ensure progress is a number, default to 0 if NaN/undefined
          const progressValue = typeof task.progress === 'number' ? task.progress : 0;
          let progressDisplay = ` (${Math.round(progressValue * 100)}%)`;
          if (task.type === gantt.config.types.project) return `${taskText}${progressDisplay}`;
          
          let taskDataInStore = findTaskInProjectsModel(task.id);
          let memberDots = "";
          if (taskDataInStore) {
              const memberIds = taskDataInStore.memberIds || [];
              const visibleMembers = members.filter(m => m.visible).map(m => m.id);
              if (visibleMembers.length > 0) {
                  memberDots = visibleMembers.map(member => `<span class="member-indicator" style="background-color:${members.find(m => m.id === member).color}; vertical-align: middle;" title="${(members.find(m => m.id === member).name || '')}"></span>`).join("");
              }
          }
          return `${taskText} ${memberDots} ${progressDisplay}`;
      };
      gantt.templates.grid_row_class = function(start, end, task) {
          let rowClass = "";
          let taskDataInStore = findTaskInProjectsModel(task.id);
          if (taskDataInStore) {
              let effectivePriority = taskDataInStore.priority || 'low';
              if (effectivePriority === 'project' && String(task.parent) !== "0") {
                  let parent = findTaskInProjectsModel(task.parent);
                  while(parent){
                      if(parent.priority && parent.priority !== 'project'){
                          effectivePriority = parent.priority;
                          break;
                      }
                      parent = findTaskInProjectsModel(parent.parent);
                  }
              }
              rowClass += ` priority-${effectivePriority}`;
          }
          if (highlightedInfo.taskIds.includes(task.id)) {
              rowClass += " " + highlightedInfo.level;
          }
          return rowClass.trim();
      };
      gantt.templates.task_class = function(start, end, task){
        let task_class = "";
        if (task.readonly) task_class += " task-locked";
        if (highlightedInfo.taskIds.includes(task.id)) task_class += " " + highlightedInfo.level;
        return task_class.trim();
      };
      gantt.templates.timeline_cell_class = function(item, date) {
        if (date.getDay() === 0 || date.getDay() === 6) return "weekend";
        return "";
      };
      gantt.templates.tooltip_text = function(start, end, task){
        const taskText = (task.text || '').replace(/^[üü°üü¢]\s*/, '').replace(/\s+\(.*?\)$/, '').trim(); 
        let html = `<b>${taskText}</b><br/>`;
        html += `<b>${translate('gantt_col_start_date')}:</b> ${gantt.templates.date_grid(start)}<br/>`;
        if (task.type !== gantt.config.types.milestone) {
            html += `<b>${translate('gantt_col_end_date')}:</b> ${gantt.templates.date_grid(gantt.calculateEndDate({start_date: start, duration: task.duration}))}<br/>`;
            html += `<b>${translate('gantt_col_duration')}:</b> ${task.duration} ${translate('gantt_col_duration').includes('(j)') ? 'j' : 'd'}<br/>`;
            // Ensure progress is a number, default to 0 if NaN/undefined
            const progressValue = typeof task.progress === 'number' ? task.progress : 0;
            html += `<b>${translate('gantt_col_progress')}:</b> ${Math.round(progressValue * 100)}%<br/>`;
        }
        let taskDataInStore = findTaskInProjectsModel(task.id);
        if (taskDataInStore && taskDataInStore.type !== gantt.config.types.project) {
            const memberIds = taskDataInStore.memberIds || [];
            if (memberIds.length > 0) {
                const memberNames = memberIds.map(id => (members.find(m => String(m.id) === String(id)) || {}).name).filter(Boolean).join(", ");
                if (memberNames) html += `<b>${translate('gantt_col_members')}:</b> ${memberNames}<br/>`;
            }
            if (taskDataInStore.comments) {
                html += `<b>${translate('custom_lightbox_task_comments_label')}:</b> ${taskDataInStore.comments.substring(0, 100)}...<br/>`;
            }
        }
        return html;
      };
      gantt.attachEvent("onBeforeLightbox", function(id){
        openCustomLightbox(id);
        return false;
      });
      gantt.attachEvent("onBeforeTaskDrag", function(id, mode, task){ return !task.readonly; });
      gantt.attachEvent("onBeforeTaskResize", function(id, mode, task){ return !task.readonly; });
      // gantt.attachEvent("onBeforeTaskAutoSchedule", function(task, start, link, predecessor){ return !task.readonly; }); // Supprim√©
      gantt.attachEvent("onBeforeTaskDisplay", function(id, task) {
          const taskData = findTaskInProjectsModel(id);
          
          // If the task itself is a project, check its visibility directly
          if (task.type === gantt.config.types.project) {
              return taskData && taskData.visible;
          }

          // For normal tasks, check if their direct project parent is visible
          if (task.parent && task.parent !== "0") {
              let currentParent = findTaskInProjectsModel(task.parent);
              while (currentParent) {
                  if (currentParent.type === gantt.config.types.project && !currentParent.visible) {
                      return false; // Parent project is not visible, so hide this task
                  }
                  currentParent = findTaskInProjectsModel(currentParent.parent); // Check grandparent
              }
          } else { // Top-level task not part of a project
              // If it's a top-level task (parent "0"), check its own visibility property if it were a project.
              // This case is less common but ensures consistency.
              if (taskData && taskData.type === gantt.config.types.task && !taskData.visible) {
                  return false;
              }
          }

          // Check member visibility for normal tasks
          if (task.type === gantt.config.types.task && taskData && taskData.memberIds) {
              const visibleMemberIds = members.filter(m => m.visible).map(m => m.id);
              // If the task has no assigned members, it's visible by default (unless project hides it)
              if (taskData.memberIds.length === 0) {
                  return true;
              }
              // If it has assigned members, it's visible only if at least one assigned member is visible
              return taskData.memberIds.some(memberId => visibleMemberIds.includes(memberId));
          }
          
          return true; // Default to visible if no specific hiding condition met
      });
      applyTranslations();
    }

    function addOrUpdateMember() {
      saveStateToHistory();
      const editMemberId = document.getElementById('editMemberId').value;
      const name = document.getElementById('memberName').value.trim();
      const color = document.getElementById('memberColor').value;
      const actionBtn = document.getElementById('memberActionBtn');
      if (!name) { showNotification('notification_enter_name', 'error'); return; }
      if (members.some(m => m.name === name && String(m.id) !== String(editMemberId))) { showNotification('notification_member_exists', 'error'); return; }
      if (editMemberId) {
        const member = members.find(m => String(m.id) === String(editMemberId));
        if (member) { member.name = name; member.color = color; showNotification('notification_member_edited', 'success', {name}); }
        document.getElementById('editMemberId').value = '';
        actionBtn.textContent = translate('add_member_btn'); actionBtn.classList.replace('btn-warning', 'btn-primary');
      } else {
        members.push({ id: crypto.randomUUID().toString(), name, color, visible: true }); // Ensure ID is string
        showNotification('notification_member_added', 'success', {name});
      }
      document.getElementById('memberName').value = ''; document.getElementById('memberColor').value = '#667eea';
      syncAndRenderGantt(); // Call central sync function
    }

    function editMember(id) {
      const member = members.find(m => String(m.id) === String(id));
      if (member) {
        document.getElementById('editMemberId').value = member.id;
        document.getElementById('memberName').value = member.name;
        document.getElementById('memberColor').value = member.color;
        const actionBtn = document.getElementById('memberActionBtn');
        actionBtn.textContent = translate('edit_member_btn'); actionBtn.classList.replace('btn-primary', 'btn-warning');
      }
    }

    function removeMember(id) {
      saveStateToHistory();
      const member = members.find(m => String(m.id) === String(id));
      const memberName = member ? member.name : '';
      members = members.filter(m => String(m.id) !== String(id));
      Object.values(projects).forEach(project => {
        function updateMemberIdsInTask(taskItem) {
            if (taskItem.memberIds) {
                taskItem.memberIds = taskItem.memberIds.filter(mid => String(mid) !== String(id));
            }
            if (taskItem.tasks) {
                taskItem.tasks.forEach(subTask => updateMemberIdsInTask(subTask));
            }
        }
        updateMemberIdsInTask(project);
        project.tasks.forEach(task => updateMemberIdsInTask(task));
      });
      syncAndRenderGantt(); // Call central sync function
      showNotification('notification_member_removed', 'success', {name: memberName});
    }

    function toggleMemberVisibility(memberId) {
      saveStateToHistory();
      const member = members.find(m => String(m.id) === String(memberId));
      if (member) {
        member.visible = !member.visible;
        // No gantt.refreshData() here, syncAndRenderGantt will handle it
        syncAndRenderGantt(); // Call central sync function
        showNotification('notification_visibility_updated', 'success', {name: member.name});
      }
    }

    function addProject() {
      saveStateToHistory();
      const name = document.getElementById('projectName').value.trim();
      if (!name) { showNotification('notification_project_name_required', 'error'); return; }
      if (Object.values(projects).some(p => p.name === name)) {
          showNotification('notification_project_exists', 'error');
          return;
      }
      const projectId = crypto.randomUUID().toString(); // Ensure ID is string
      const today = new Date();
      const startDate = (daysOffset) => {
          const date = gantt.date.add(today, daysOffset, 'day');
          if (gantt.config.skip_off_time) {
              while (!gantt.isWorkTime({date: date, unit: "day"})) {
                  date.setDate(date.getDate() + 1);
              }
          }
          return gantt.date.date_to_str(gantt.config.date_format)(date);
      };

      const defaultTasksTemplates = [
        { key: 'default_task_cahier_des_charges', duration: 5, initialDelay: 0 },
        { key: 'default_task_conception_pedagogique', duration: 7, initialDelay: 5 },
        { key: 'default_task_production_contenus', duration: 10, initialDelay: 12 },
        { key: 'default_task_developpement_interactif', duration: 8, initialDelay: 22 },
        { key: 'default_task_tests_validation', duration: 5, initialDelay: 30 }
      ];
      
      let currentCalcDate = new Date(today); // Use a mutable date for calculations

      const tasks = defaultTasksTemplates.map((taskTemplate) => {
        const taskName = translate(taskTemplate.key, { projectName: name });
        
        let taskStartDate = gantt.date.add(currentCalcDate, taskTemplate.initialDelay, "day");
        if (gantt.config.skip_off_time) {
            while (!gantt.isWorkTime({date: taskStartDate, unit: "day"})) {
                taskStartDate.setDate(taskStartDate.getDate() + 1);
            }
        }
        
        const taskObj = {
          id: crypto.randomUUID().toString(), name: taskName, text: taskName, 
          start: gantt.date.date_to_str(gantt.config.date_format)(taskStartDate), 
          duration: taskTemplate.duration,
          progress: 0, project: name, parent: projectId, 
          memberIds: members.length > 0 ? [members[Math.floor(Math.random() * members.length)].id] : [],
          priority: document.getElementById('projectPriority').value,
          comments: "", color: "#5cb85c", type: gantt.config.types.task, locked: false
        };
        // Calculate end date after duration is set
        const taskEndDate = gantt.calculateEndDate({start_date: gantt.date.str_to_date(gantt.config.date_format)(taskObj.start), duration: taskObj.duration});
        taskObj.end = gantt.date.date_to_str(gantt.config.date_format)(taskEndDate);
        
        return taskObj;
      });

      let projectStartDate = tasks.length > 0 ? tasks[0].start : gantt.date.date_to_str(gantt.config.date_format)(today);
      let projectEndDate = tasks.length > 0 ? tasks[tasks.length - 1].end : gantt.date.date_to_str(gantt.config.date_format)(gantt.calculateEndDate({start_date: today, duration: 30}));
      let projectDuration = tasks.length > 0 ? gantt.calculateDuration({
          start_date: gantt.date.str_to_date(gantt.config.date_format)(projectStartDate),
          end_date: gantt.date.str_to_date(gantt.config.date_format)(projectEndDate)
      }) : 30;
      
      projects[projectId] = {
        name, description: document.getElementById('projectDescription').value, deadline: document.getElementById('projectDeadline').value,
        priority: document.getElementById('projectPriority').value, color: document.getElementById('projectColor').value,
        tasks: tasks, id: projectId, visible: true, type: gantt.config.types.project, parent: "0",
        start: projectStartDate, end: projectEndDate, duration: projectDuration, progress: 0, locked: false
      };
      document.getElementById('projectName').value = ''; document.getElementById('projectDescription').value = '';
      document.getElementById('projectDeadline').value = ''; document.getElementById('projectPriority').value = 'low';
      document.getElementById('projectColor').value = '#28a745';
      syncAndRenderGantt(); // Call central sync function
      showNotification('notification_project_created', 'success', {name});
    }

    function toggleProjectVisibility(projectId) {
        saveStateToHistory();
        if (projects[projectId]) {
            projects[projectId].visible = !projects[projectId].visible;
            syncAndRenderGantt(); // Call central sync function
        }
    }

    function removeProject(projectId) {
        const projectToRemove = projects[projectId];
        if (!projectToRemove) {
            console.error("Project to remove not found:", projectId);
            return;
        }

        if (confirm(translate('clear_all_data_confirm_project', {name: projectToRemove.name}))) {
            saveStateToHistory();

            const allTaskIdsToRemove = [];
            function collectTaskIds(task) {
                allTaskIdsToRemove.push(task.id);
                if (task.tasks && task.tasks.length > 0) {
                    task.tasks.forEach(collectTaskIds);
                }
            }
            collectTaskIds(projectToRemove);

            allLinks = allLinks.filter(link => 
                !allTaskIdsToRemove.includes(String(link.source)) && 
                !allTaskIdsToRemove.includes(String(link.target))
            );

            delete projects[projectId];
            
            syncAndRenderGantt(); // Call central sync function

            showNotification('notification_project_removed', 'success', {name: projectToRemove.name});
        }
    }

    function addTask() {
        saveStateToHistory();
        const taskName = document.getElementById('taskName').value.trim();
        const taskType = document.getElementById('taskType').value;
        let parentIdFromSelect = document.getElementById('taskProject').value;
        if (!taskName) {
            showNotification('notification_enter_name', 'error');
            return;
        }
        if (taskType === 'project') {
            if (parentIdFromSelect === "0") { // Top-level project
                // OK, it's a new top-level project
            } else {
                const selectedParent = findTaskInProjectsModel(parentIdFromSelect);
                if (!selectedParent || selectedParent.type !== gantt.config.types.project) {
                    showNotification('validation_mother_task_parent_required', 'error');
                    return;
                }
            }
        } else {
            parentIdFromSelect = parentIdFromSelect || "0";
        }
        let newTaskData = {
            id: crypto.randomUUID().toString(), name: taskName, text: taskName, comments: "", // Ensure ID is string
            color: "#5cb85c", type: taskType, parent: parentIdFromSelect, locked: false
        };
        if (taskType === 'task') {
            const progress = parseFloat(document.getElementById('taskProgress').value);
            const assignedMemberIds = Array.from(document.getElementById('taskMembers').querySelectorAll('input:checked')).map(input => input.value);
            const taskPriority = document.getElementById('taskPriority').value;
            const taskStartPicker = datePickers.find(picker => picker.element.id === 'taskStart');
            const taskEndPicker = datePickers.find(picker => picker.element.id === 'taskEnd');
            const taskDurationInput = document.getElementById('taskDuration');
            const startDateObject = taskStartPicker.selectedDates.length > 0 ? taskStartPicker.selectedDates[0] : null;
            let endDateObject = taskEndPicker.selectedDates.length > 0 ? taskEndPicker.selectedDates[0] : null;
            let durationValue = parseInt(taskDurationInput.value);
            if (!startDateObject || (!endDateObject && (isNaN(durationValue) || durationValue <= 0)) || (endDateObject && isNaN(durationValue))) {
                showNotification('notification_fill_all_fields', 'error');
                return;
            }
            if (endDateObject && taskEndPicker.selectedDates.length > 0) {
                durationValue = gantt.calculateDuration({start_date: startDateObject, end_date: endDateObject});
            } else if (!isNaN(durationValue) && durationValue > 0) {
                endDateObject = gantt.calculateEndDate({start_date: startDateObject, duration: durationValue});
            } else {
                showNotification('notification_fill_all_fields', 'error');
                return;
            }
            if (endDateObject < startDateObject) {
                showNotification('notification_invalid_date_format', 'error');
                return;
            }
            newTaskData.start = gantt.date.date_to_str(gantt.config.date_format)(startDateObject);
            newTaskData.end = gantt.date.date_to_str(gantt.config.date_format)(endDateObject);
            newTaskData.duration = durationValue;
            newTaskData.progress = progress;
            newTaskData.memberIds = assignedMemberIds;
            newTaskData.priority = taskPriority;
        } else {
            newTaskData.color = "#667eea";
            newTaskData.priority = document.getElementById('projectPriority').value || 'low';
            newTaskData.start = null;
            newTaskData.end = null;
            newTaskData.duration = 0;
            newTaskData.progress = 0;
            newTaskData.open = true;
            newTaskData.tasks = [];
        }
        
        const parentData = findTaskInProjectsModel(parentIdFromSelect);
        if (parentData) {
            if (!parentData.tasks) {
                parentData.tasks = [];
            }
            parentData.tasks.push(newTaskData);
        } else if (parentIdFromSelect === "0") {
            projects[newTaskData.id] = newTaskData;
        }

        document.getElementById('taskProject').value = '';
        document.getElementById('taskName').value = '';
        document.getElementById('taskType').value = 'task';
        toggleNewTaskFieldsVisibility(); 
        datePickers.forEach(picker => picker.clear());
        document.getElementById('taskDuration').value = '';
        document.getElementById('taskProgress').value = '0';
        document.getElementById('taskPriority').value = 'project';
        document.getElementById('taskMembers').querySelectorAll('input:checked').forEach(input => input.checked = false);
        
        syncAndRenderGantt(); // Call central sync function
        showNotification('notification_task_added', 'success', { name: taskName });
    }

    function showTaskMembersLightbox(taskId) {
      const ganttTask = gantt.getTask(taskId);
      if (!ganttTask || ganttTask.type === gantt.config.types.project) {
        showNotification('Cannot manage members for mother tasks directly. Members are assigned to individual tasks.', 'error');
        return;
      }
      let taskData = findTaskInProjectsModel(taskId);
      if (!taskData) { return; }
      document.getElementById('editTaskId').value = taskId;
      const container = document.getElementById('editTaskMembersList');
      container.innerHTML = members.length === 0 ? translate('notification_no_members') : members.map(m => `
        <div class="form-check">
          <input class="form-check-input" type="checkbox" value="${m.id}" id="edit-task-member-${m.id}" name="edit-task-member-${m.id}" ${(taskData.memberIds || []).includes(String(m.id)) ? 'checked' : ''}>
          <label class="form-check-label" for="edit-task-member-${m.id}">
            <span class="member-indicator" style="background-color: ${m.color};"></span> ${m.name}
          </label>
        </div>`).join('');
      document.getElementById('editTaskMembersModalLabel').textContent = `${translate('manage_task_members_modal_title_prefix')}: ${(ganttTask.text || '').replace(/^[üî¥üü°üü¢]\s*/, '')}`;
      new bootstrap.Modal(document.getElementById('editTaskMembersModal')).show();
    }

    function saveTaskMembers() {
      saveStateToHistory();
      const taskId = document.getElementById('editTaskId').value;
      let taskData = findTaskInProjectsModel(taskId);
      if (!taskData) { return; }
      const assignedMemberIds = Array.from(document.getElementById('editTaskMembersList').querySelectorAll('input:checked')).map(input => input.value);
      taskData.memberIds = assignedMemberIds;
      // No need to manually recalculate parents here, syncAndRenderGantt will handle it.
      showNotification('notification_task_members_updated', 'success', {name: (taskData.name || '').replace(/^[?üü°üü¢]\s*/, '')});
      const modalInstance = bootstrap.Modal.getInstance(document.getElementById('editTaskMembersModal'));
      if (modalInstance) modalInstance.hide();
      syncAndRenderGantt(); // Call central sync function
    }

    function exportToJSON() {
      const data = { members, projects, allLinks, currentLang };
      const jsonString = JSON.stringify(data, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'gantt_data.json'; a.click();
      URL.revokeObjectURL(url);
      showNotification('notification_export_success');
    }

    function importFromJSON(event) {
        saveStateToHistory();
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const rawData = JSON.parse(e.target.result);
                console.log("[DEBUG] importFromJSON: Raw data loaded:", JSON.parse(JSON.stringify(rawData)));

                if (!rawData.members || !rawData.projects || !rawData.allLinks) {
                    throw new Error(translate('notification_invalid_json_format'));
                }

                gantt.clearAll(); // Clear Gantt chart
                
                const idMap = new Map(); // Maps old IDs to new UUIDs

                // 1. Generate new UUIDs for all members and map them
                const remappedMembers = rawData.members.map(m => {
                    const newId = crypto.randomUUID().toString();
                    idMap.set(String(m.id), newId);
                    console.log("[DEBUG] ID Mapped (Member):", m.id, "->", newId);
                    return { ...m, id: newId };
                });

                // 2. Recursive function to process tasks and generate new IDs
                const processTaskAndMapId = (originalTask) => {
                    const oldId = String(originalTask.id);
                    // Ensure a new ID is generated only if it hasn't been mapped already
                    if (!idMap.has(oldId)) {
                        idMap.set(oldId, crypto.randomUUID().toString());
                        console.log("[DEBUG] ID Mapped (Task/Project):", oldId, "->", idMap.get(oldId));
                    }
                    // Force visibility to true upon import for all tasks/projects
                    const newTask = { 
                        ...originalTask, 
                        id: idMap.get(oldId),
                        visible: true 
                    };
                    console.log("[DEBUG] Processing task (pre-parent/member update):", originalTask.name, "(Old ID:", originalTask.id, ", New ID:", newTask.id, ", Type:", originalTask.type, ", Original Parent:", originalTask.parent, ", Forced Visible:", newTask.visible, ")");

                    // Recursively process children tasks
                    if (originalTask.tasks) {
                        console.log("[DEBUG] Recursively processing children for:", originalTask.name, "(Old ID:", originalTask.id, ")");
                        newTask.tasks = originalTask.tasks.map(processTaskAndMapId);
                    }
                    return newTask;
                };

                // 3. Process all projects and their nested tasks to get new IDs
                const processedProjects = {};
                console.log("[DEBUG] Starting processing of top-level projects.");
                Object.values(rawData.projects).forEach(originalProject => {
                    const newProject = processTaskAndMapId(originalProject);
                    processedProjects[newProject.id] = newProject;
                });
                console.log("[DEBUG] All projects processed for new IDs. Current processedProjects structure:", JSON.parse(JSON.stringify(processedProjects)));
                console.log("[DEBUG] Current ID Map state:", JSON.parse(JSON.stringify(Array.from(idMap.entries()))));


                // 4. Now, re-link parents and memberIds using the new IDs
                const finalizeTask = (task) => {
                    const oldParentId = task.parent; // Keep original parent for logging
                    // Update parent ID
                    if (task.parent && String(task.parent) !== "0") {
                        const newParentId = idMap.get(String(task.parent));
                        if (newParentId) {
                            task.parent = newParentId;
                            console.log("[DEBUG] Finalizing task:", task.name, "(ID:", task.id, ") - Parent updated from", oldParentId, "to", task.parent);
                        } else {
                            // If parent not found in map, it might be a top-level task that was previously nested
                            // Or an error in the original data/mapping. Default to "0".
                            task.parent = "0";
                            console.warn("[WARN] Finalizing task:", task.name, "(ID:", task.id, ") - Original parent", oldParentId, "not found in ID map, setting parent to '0'.");
                        }
                    } else {
                        task.parent = "0"; // Ensure top-level tasks have parent "0"
                        console.log("[DEBUG] Finalizing task:", task.name, "(ID:", task.id, ") - Parent remains '0'.");
                    }

                    // Update member IDs
                    if (task.memberIds) {
                        task.memberIds = task.memberIds.map(oldMemberId => {
                            const newMemberId = idMap.get(String(oldMemberId));
                            if (!newMemberId) {
                                console.warn("[WARN] Finalizing task:", task.name, "(ID:", task.id, ") - Member ID", oldMemberId, "not found in ID map.");
                            }
                            return newMemberId;
                        }).filter(Boolean); // Filter out any null/undefined if member ID wasn't found
                        console.log("[DEBUG] Finalizing task:", task.name, "(ID:", task.id, ") - Member IDs updated.");
                    }

                    // Recursively finalize children
                    if (task.tasks) {
                        console.log("[DEBUG] Finalizing children for:", task.name, "(ID:", task.id, ")");
                        task.tasks.forEach(finalizeTask);
                    }
                };
                
                console.log("[DEBUG] Starting finalization of tasks (parent/member re-linking).");
                Object.values(processedProjects).forEach(finalizeTask);
                console.log("[DEBUG] All tasks finalized. Final processedProjects structure:", JSON.parse(JSON.stringify(processedProjects)));


                // 5. Remap links using the new IDs
                const remappedLinks = rawData.allLinks.map(link => {
                    const newSource = idMap.get(String(link.source));
                    const newTarget = idMap.get(String(link.target));
                    if (newSource && newTarget) {
                        console.log("[DEBUG] Remapping link:", link.id, "Source:", link.source, "->", newSource, "Target:", link.target, "->", newTarget);
                        return {
                            id: crypto.randomUUID().toString(), // New ID for link itself
                            source: newSource,
                            target: newTarget,
                            type: String(link.type)
                        };
                    }
                    console.warn("[WARN] Skipping link due to unmapped source or target:", link);
                    return null;
                }).filter(Boolean);

                // 6. Update global state
                members = remappedMembers;
                projects = processedProjects; // Use the processed projects with remapped IDs and correct parents
                allLinks = remappedLinks;
                currentLang = rawData.currentLang || 'fr';

                setLanguage(currentLang);
                syncAndRenderGantt();
                showNotification('notification_import_success');
                document.getElementById('importJSON').value = '';

            } catch (error) {
                showNotification('notification_import_error', 'error', { message: error.message });
                console.error("Import error:", error);
            }
        };
        reader.readAsText(file);
    }

    function toggleCustomLightboxFieldsVisibility() {
        const taskType = document.getElementById('customLightboxTaskType').value;
        const normalFields = document.getElementById('customLightboxNormalTaskFields');
        const projectFields = document.getElementById('customLightboxProjectFields');
        const summaryNote = document.getElementById('customLightboxSummaryTaskFields');

        if (taskType === 'task') {
            normalFields.style.display = 'block';
            projectFields.style.display = 'none';
            summaryNote.style.display = 'none';
        } else { // 'project' type
            normalFields.style.display = 'none';
            projectFields.style.display = 'block';
            summaryNote.style.display = 'block';
        }
    }


    function openCustomLightbox(id) {
        elementToFocusOnModalClose = document.activeElement;
        currentEditingTaskId = id;
        const ganttTask = gantt.getTask(id);
        if (!ganttTask) return;
        document.getElementById('customLightboxTaskId').value = id;
        document.getElementById('customLightboxTaskName').value = (ganttTask.text || '').replace(/^[üî¥üü°üü¢]\s*/, '');
        
        document.getElementById('customLightboxTaskType').value = ganttTask.type;
        toggleCustomLightboxFieldsVisibility();
        
        populateProjectDropdown('customLightboxTaskParent', ganttTask.parent, id, true, true); 
        
        if (ganttTask.type === gantt.config.types.project) {
            const projectData = findTaskInProjectsModel(id) || {};
            document.getElementById('customLightboxProjectDescription').value = projectData.description || "";
            const startPicker = datePickers.find(p => p.element.id === 'customLightboxProjectStart');
            if(startPicker) startPicker.setDate(ganttTask.start_date, false);
            const endPicker = datePickers.find(p => p.element.id === 'customLightboxProjectEnd');
            if(endPicker) endPicker.setDate(ganttTask.end_date, false);
            document.getElementById('customLightboxProjectColor').value = projectData.color || '#667eea';
            document.getElementById('customLightboxProjectPriority').value = projectData.priority || 'low';
        } else { // It's a task
            let taskDataStore = findTaskInProjectsModel(id);
            const startPicker = datePickers.find(p => p.element.id === 'customLightboxTaskStart');
            const endPicker = datePickers.find(p => p.element.id === 'customLightboxTaskEnd');
            if (ganttTask.start_date && startPicker) startPicker.setDate(ganttTask.start_date, false);
            if (ganttTask.end_date && endPicker) endPicker.setDate(ganttTask.end_date, false);
            document.getElementById('customLightboxTaskDuration').value = ganttTask.duration || 0;
            document.getElementById('customLightboxTaskProgress').value = (taskDataStore ? taskDataStore.progress : ganttTask.progress) || 0;
            const priorityToSet = (taskDataStore && typeof taskDataStore.priority !== 'undefined') ? taskDataStore.priority : 'project';
            document.getElementById('customLightboxTaskPriority').value = priorityToSet;
            document.getElementById('customLightboxTaskComments').value = (taskDataStore && taskDataStore.comments) || "";
            document.getElementById('customLightboxTaskColor').value = (taskDataStore && taskDataStore.color) || "#5cb85c";
            const membersContainer = document.getElementById('customLightboxTaskMembers');
            membersContainer.innerHTML = members.length === 0 ? translate('notification_no_members') : members.map(m => `
                <div class="form-check">
                <input class="form-check-input" type="checkbox" value="${m.id}" id="custom-lightbox-member-${m.id}" name="custom-lightbox-member-${m.id}" ${(taskDataStore && taskDataStore.memberIds && taskDataStore.memberIds.includes(String(m.id))) ? 'checked' : ''}>
                <label class="form-check-label" for="custom-lightbox-member-${m.id}">
                    <span class="member-indicator" style="background-color: ${m.color};"></span> ${m.name}
                </label>
                </div>`).join('');
        }
        document.getElementById('customTaskModalLabel').textContent = translate('custom_lightbox_title') + (ganttTask.text ? `: ${(ganttTask.text || '').replace(/^[üî¥üü¢]\s*/, '').trim().substring(0,30)}...` : '');
        if (!customTaskModalInstance) {
            customTaskModalInstance = new bootstrap.Modal(document.getElementById('customTaskModal'));
        }
        customTaskModalInstance.show();
        applyTranslations();
    }

    function closeCustomLightbox() {
        if (customTaskModalInstance) customTaskModalInstance.hide();
        if (elementToFocusOnModalClose) elementToFocusOnModalClose.focus();
        currentEditingTaskId = null;
        elementToFocusOnModalClose = null;
    }

    function saveCustomLightboxChanges() {
        saveStateToHistory();
        if (!currentEditingTaskId) return;

        const taskData = findTaskInProjectsModel(currentEditingTaskId);
        if (!taskData) {
            showNotification(`Save failed: Task not found in data model for ID: ${currentEditingTaskId}.`, 'error', {}, true);
            return;
        }

        const originalType = taskData.type;
        const newType = document.getElementById('customLightboxTaskType').value;
        const taskName = document.getElementById('customLightboxTaskName').value.trim();
        let newParentIdFromLightbox = document.getElementById('customLightboxTaskParent').value || "0"; // Get the selected parent ID
        
        if (!taskName) {
            showNotification('notification_enter_name', 'error');
            return;
        }
        
        // Validate parent for 'project' type tasks
        if (newType === 'project') {
            if (newParentIdFromLightbox !== "0") { // If it's not becoming a top-level project
                const selectedParent = findTaskInProjectsModel(newParentIdFromLightbox);
                if (!selectedParent || selectedParent.type !== gantt.config.types.project) {
                    showNotification('validation_mother_task_parent_required', 'error');
                    return; // Prevent saving if parent is not a project/mother task
                }
            }
        }

        // Store original parent before any potential changes
        const oldParentId = taskData.parent;
        let finalNewParentId = newParentIdFromLightbox; // Assume the selected parent is the final one

        // --- Update task properties based on type ---
        taskData.name = taskName;
        taskData.text = taskName;
        taskData.type = newType;

        if (originalType === 'task' && newType === 'project') {
            const ganttTask = gantt.getTask(currentEditingTaskId);
            if (ganttTask && gantt.hasChild(ganttTask.id)) {
                showNotification('Cannot convert a normal task with sub-tasks to a project. Please move or delete sub-tasks first.', 'error');
                return;
            }
            // Transition from task to project
            taskData.start = null;
            taskData.end = null;
            taskData.duration = 0;
            taskData.progress = 0;
            taskData.open = true;
            taskData.memberIds = [];
            taskData.comments = "";
            taskData.color = document.getElementById('customLightboxProjectColor').value;
            taskData.priority = document.getElementById('customLightboxProjectPriority').value;
            taskData.tasks = taskData.tasks || []; // Ensure tasks array exists for a project
        } else if (newType === 'project') {
            // It's a project, update project specific fields
            taskData.description = document.getElementById('customLightboxProjectDescription').value;
            const startPicker = datePickers.find(p => p.element.id === 'customLightboxProjectStart');
            const endPicker = datePickers.find(p => p.element.id === 'customLightboxProjectEnd');
            const newStartDate = startPicker.selectedDates[0];
            const newEndDate = endPicker.selectedDates[0];
            if (newStartDate && newEndDate && newEndDate >= newStartDate) {
                taskData.start = gantt.date.date_to_str(gantt.config.date_format)(newStartDate);
                taskData.end = gantt.date.date_to_str(gantt.config.date_format)(newEndDate);
                taskData.duration = gantt.calculateDuration({start_date: newStartDate, end_date: newEndDate});
            } else {
                taskData.start = null;
                taskData.end = null;
                taskData.duration = 0;
            }
            taskData.color = document.getElementById('customLightboxProjectColor').value;
            taskData.priority = document.getElementById('customLightboxProjectPriority').value;
        } else {
            // Transition from project to task or just updating a normal task
            if (originalType === 'project' && newType === 'task') {
                const ganttTask = gantt.getTask(currentEditingTaskId);
                if (ganttTask && gantt.hasChild(ganttTask.id)) {
                    showNotification('Cannot convert a project with sub-tasks to a normal task. Please move or delete sub-tasks first.', 'error');
                    return;
                }
                delete taskData.tasks; // A normal task cannot have sub-tasks
            }
            taskData.progress = parseFloat(document.getElementById('customLightboxTaskProgress').value);
            taskData.priority = document.getElementById('customLightboxTaskPriority').value;
            taskData.comments = document.getElementById('customLightboxTaskComments').value;
            taskData.color = document.getElementById('customLightboxTaskColor').value;
            taskData.memberIds = Array.from(document.getElementById('customLightboxTaskMembers').querySelectorAll('input:checked')).map(input => input.value);
            
            const startPicker = datePickers.find(p => p.element.id === 'customLightboxTaskStart');
            const endPicker = datePickers.find(p => p.element.id === 'customLightboxTaskEnd');
            const newStartDate = startPicker.selectedDates[0];
            const newEndDate = endPicker.selectedDates[0];

            if (!newStartDate || !newEndDate || newEndDate < newStartDate) {
                showNotification('notification_invalid_date_format', 'error');
                return; 
            }
            
            const finalDuration = gantt.calculateDuration({start_date: newStartDate, end_date: newEndDate});

            taskData.start = gantt.date.date_to_str(gantt.config.date_format)(newStartDate);
            taskData.end = gantt.date.date_to_str(gantt.config.date_format)(newEndDate);
            taskData.duration = finalDuration;
        }
        
        // --- Handle parent change in the model ---
        if (oldParentId !== finalNewParentId) {
            // Remove from old parent
            const oldParentData = findTaskInProjectsModel(oldParentId);
            if (oldParentData && oldParentData.tasks) {
                const index = oldParentData.tasks.findIndex(t => t.id === currentEditingTaskId);
                if (index > -1) {
                    oldParentData.tasks.splice(index, 1);
                }
            } else if (oldParentId === "0") { // Was a top-level project/task
                delete projects[currentEditingTaskId];
            }

            // Add to new parent
            let newParentData = null;
            if (finalNewParentId !== "0") {
                newParentData = findTaskInProjectsModel(finalNewParentId);
            }

            if (newParentData) {
                if (!newParentData.tasks) {
                    newParentData.tasks = [];
                }
                newParentData.tasks.push(taskData);
                taskData.parent = finalNewParentId; // Update parent ID in taskData
            } else if (finalNewParentId === "0") { // New parent is root (0)
                 projects[currentEditingTaskId] = taskData;
                 taskData.parent = "0"; // Update parent ID in taskData
            } else {
                // CRITICAL: New parent not found and it's not root. Task would disappear.
                // Force to top-level to prevent loss.
                showNotification(`‚ö†Ô∏è Impossible de trouver le nouveau parent. La t√¢che '${taskName}' a √©t√© d√©plac√©e √† la racine.`, 'warning', {}, true);
                
                projects[currentEditingTaskId] = taskData; // Place it at the root
                taskData.parent = "0"; // Ensure its parent is updated to "0" in the model
            }
        }

        showNotification('notification_task_updated', 'success', {name: taskName});
        closeCustomLightbox();
        
        syncAndRenderGantt(); // Call central sync function after all model changes
    }

    function deleteTaskFromCustomLightbox() {
        if (!currentEditingTaskId) return;
        const taskToDelete = findTaskInProjectsModel(currentEditingTaskId);
        if (!taskToDelete) return;
        
        const confirmMessage = taskToDelete.type === 'project' ? 
            translate('clear_all_data_confirm_project', {name: taskToDelete.name}) :
            translate('clear_all_data_confirm_task', {name: taskToDelete.name});

        if (confirm(confirmMessage)) {
            gantt.deleteTask(currentEditingTaskId); // This will trigger onAfterTaskDelete
            closeCustomLightbox();
        }
    }

    function updateLightboxSchedule(source) {
        const startPicker = datePickers.find(p => p.element.id === 'customLightboxTaskStart');
        const endPicker = datePickers.find(p => p.element.id === 'customLightboxTaskEnd');
        const durationInput = document.getElementById('customLightboxTaskDuration');
        if (!startPicker || !endPicker || !durationInput) {
            return;
        }
        const startDate = startPicker.selectedDates[0];
        const endDate = endPicker.selectedDates[0];
        const duration = parseInt(durationInput.value, 10);
        if (source === 'start') {
            if (startDate && !isNaN(duration)) {
                const newEndDate = gantt.calculateEndDate({ start_date: startDate, duration: duration });
                endPicker.setDate(newEndDate, false);
            }
        } else if (source === 'end') {
            if (startDate && endDate) {
                if (endDate < startDate) {
                    endPicker.setDate(startDate, false);
                    durationInput.value = gantt.calculateDuration({start_date: startDate, end_date: startDate});
                } else {
                    const newDuration = gantt.calculateDuration({ start_date: startDate, end_date: endDate });
                    durationInput.value = newDuration;
                }
            }
        } else if (source === 'duration') {
            if (startDate && !isNaN(duration)) {
                const newEndDate = gantt.calculateEndDate({ start_date: startDate, duration: duration });
                endPicker.setDate(newEndDate, false);
            }
        }
    }

    function calculateMemberWorkload() {
        memberWorkload = {};
        const dateToStr = gantt.date.date_to_str("%Y-%m-%d");
        gantt.eachTask(function(task) {
            // Only consider tasks that are currently visible in the Gantt chart for workload calculation
            if (gantt.isTaskVisible(task.id) && task.type === gantt.config.types.task) {
                const taskData = findTaskInProjectsModel(task.id);
                if (taskData && taskData.memberIds && taskData.memberIds.length > 0) {
                    for (let d = new Date(task.start_date); d < task.end_date; d.setDate(d.getDate() + 1)) {
                        if (gantt.isWorkTime({ date: d, unit: "day" })) {
                            const dateStr = dateToStr(d);
                            taskData.memberIds.forEach(memberId => {
                                if (!memberWorkload[dateStr]) memberWorkload[dateStr] = {};
                                if (!memberWorkload[dateStr][memberId]) memberWorkload[dateStr][memberId] = 0;
                                memberWorkload[dateStr][memberId]++;
                            });
                        }
                    }
                }
            }
        });
    }

    function getMemberOverload(memberId) {
        const overloadedDays = [];
        const dateToLocaleStr = gantt.date.date_to_str(getGanttDateFormatForLocale(currentLang));
        for (const date in memberWorkload) {
            if (memberWorkload[date][memberId] && memberWorkload[date][memberId] >= 3) {
                const formattedDate = dateToLocaleStr(gantt.date.str_to_date("%Y-%m-%d")(date));
                const icon = memberWorkload[date][memberWorkload[date][memberId]] >= 4 ? 'üíÄ' : '‚ö†Ô∏è';
                overloadedDays.push({ date: formattedDate, icon: icon, rawDate: date });
            }
        }
        return overloadedDays;
    }

    function exportGanttToPNG() {
        if (!gantt || gantt.getTaskCount() === 0) {
            showNotification("notification_no_tasks_to_export", 'error');
            return;
        }
        const { min_date, max_date } = gantt.getSubtaskDates();
        const styles = `
            <style>
                body { font-family: 'Segoe UI', sans-serif; }
                .gantt_task_cell.weekend { background-color: #f0f0f0 !important; }
                .member-indicator { display: none; }
                .gantt_task_line { border-radius: 4px !important; }
                .gantt_task_progress { border-radius: 4px !important; }
                .priority-low { background-color: #d4edda !important; }
                .priority-medium { background-color: #fff3cd !important; }
                .priority-high { background-color: #f8d7da !important; }
            </style>
        `;
        gantt.exportToPNG({ name: "gantt_diagram.png", raw: true, header: styles, start_date: min_date, end_date: max_date });
        showNotification("notification_png_exported");
    }

    function confirmClearAllData() {
        if (confirm(translate('clear_all_data_confirm'))) {
            clearAllData();
        }
    }

    function clearAllData() {
        saveStateToHistory();
        members = [];
        projects = {};
        allLinks = [];
        syncAndRenderGantt(); // Call central sync function
        showNotification('notification_all_data_cleared', 'success');
    }

    function initDummyData() {
      members = [
        { id: 'm1', name: 'Alice', color: '#FF8A80', visible: true },
        { id: 'm2', name: 'Bob', color: '#82B1FF', visible: true },
        { id: 'm3', name: 'Charlie', color: '#B9F6CA', visible: true },
        { id: 'm4', name: 'Diana', color: '#FFD180', visible: true },
        { id: 'm5', name: 'Eve', color: '#C5CAE9', visible: true }
      ];

      const today = new Date();
      const startDate = (daysOffset) => gantt.date.date_to_str(gantt.config.date_format)(gantt.date.add(today, daysOffset, 'day'));

      projects = {}; // Reset projects

      // Project 1: Lancement d'un nouveau produit (New Product Launch)
      const p1Id = 'proj_new_product';
      projects[p1Id] = {
          id: p1Id, name: "Lancement d'un nouveau produit", description: "Plan complet pour le lancement d'un produit innovant.", deadline: startDate(90),
          priority: 'high', color: '#8E44AD', visible: true, type: gantt.config.types.project, parent: "0", open: true,
          tasks: [
              { id: 'p1_t1', name: 'Phase de Recherche', type: gantt.config.types.project, parent: p1Id, open: true, tasks: [
                  { id: 'p1_t1_1', name: '√âtude de march√© approfondie', start: startDate(0), duration: 10, progress: 0.9, parent: 'p1_t1', memberIds: ['m1', 'm4'], type: 'task', comments: "Analyser les tendances du march√© et les besoins des clients." },
                  { id: 'p1_t1_2', name: 'Analyse concurrentielle d√©taill√©e', start: startDate(5), duration: 8, progress: 0.7, parent: 'p1_t1', memberIds: ['m2'], type: 'task', comments: "Identifier les forces et faiblesses des concurrents." },
                  { id: 'p1_t1_3', name: 'Sp√©cifications techniques du produit', start: startDate(10), duration: 5, progress: 0.5, parent: 'p1_t1', memberIds: ['m1', 'm3'], type: 'task', comments: "D√©finir les fonctionnalit√©s cl√©s et les exigences techniques." },
              ]},
              { id: 'p1_t2', name: 'Phase de D√©veloppement', type: gantt.config.types.project, parent: p1Id, open: true, tasks: [
                  { id: 'p1_t2_1', name: 'D√©veloppement du prototype initial', start: startDate(15), duration: 15, progress: 0.2, parent: 'p1_t2', memberIds: ['m2', 'm3'], type: 'task', comments: "Premi√®re version fonctionnelle du produit." },
                  { id: 'p1_t2_2', name: 'Design UI/UX et maquettes', start: startDate(15), duration: 8, progress: 0.4, parent: 'p1_t2', memberIds: ['m4'], type: 'task', comments: "Cr√©ation de l'interface utilisateur et de l'exp√©rience utilisateur." },
                  { id: 'p1_t2_3', name: 'Tests internes et d√©bogage', start: startDate(30), duration: 7, progress: 0, parent: 'p1_t2', memberIds: ['m3', 'm5'], type: 'task', comments: "Assurer la qualit√© et la stabilit√© du logiciel." },
              ]},
              { id: 'p1_t3', name: 'Phase Marketing et Lancement', type: gantt.config.types.project, parent: p1Id, open: true, tasks: [
                  { id: 'p1_t3_1', name: 'Cr√©ation du site web de lancement', start: startDate(35), duration: 10, progress: 0.1, parent: 'p1_t3', memberIds: ['m4'], type: 'task', comments: "D√©velopper la page d'atterrissage et les informations produit." },
                  { id: 'p1_t3_2', name: 'Campagne publicitaire pr√©-lancement', start: startDate(40), duration: 15, progress: 0, parent: 'p1_t3', memberIds: ['m1', 'm2'], type: 'task', comments: "Pr√©parer les annonces et les partenariats." },
                  { id: 'p1_t3_3', name: 'Lancement officiel du produit', start: startDate(55), duration: 1, progress: 0, parent: 'p1_t3', memberIds: ['m1', 'm2', 'm3', 'm4', 'm5'], type: gantt.config.types.milestone, locked: true, comments: "Jour J du lancement!" }
              ]}
          ]
      };

      // Project 2: Refonte du site web (Website Redesign)
      const p2Id = 'proj_website_redesign';
      projects[p2Id] = {
          id: p2Id, name: "Refonte du site web", description: "Modernisation de l'interface et am√©lioration des performances.", deadline: startDate(70),
          priority: 'medium', color: '#27AE60', visible: true, type: gantt.config.types.project, parent: "0", open: true,
          tasks: [
              { id: 'p2_t1', name: 'Analyse et Planification', type: gantt.config.types.project, parent: p2Id, open: true, tasks: [
                  { id: 'p2_t1_1', name: 'Audit du site existant', start: startDate(5), duration: 7, progress: 0.8, parent: 'p2_t1', memberIds: ['m5'], type: 'task' },
                  { id: 'p2_t1_2', name: 'D√©finition des objectifs', start: startDate(7), duration: 3, progress: 1, parent: 'p2_t1', memberIds: ['m1', 'm5'], type: 'task' },
              ]},
              { id: 'p2_t2', name: 'Conception et D√©veloppement', type: gantt.config.types.project, parent: p2Id, open: true, tasks: [
                  { id: 'p2_t2_1', name: 'Wireframing et Prototypage', start: startDate(12), duration: 10, progress: 0.6, parent: 'p2_t2', memberIds: ['m4'], type: 'task' },
                  { id: 'p2_t2_2', name: 'D√©veloppement Front-end', start: startDate(15), duration: 20, progress: 0.3, parent: 'p2_t2', memberIds: ['m2', 'm3'], type: 'task' },
                  { id: 'p2_t2_3', name: 'D√©veloppement Back-end', start: startDate(20), duration: 18, progress: 0.1, parent: 'p2_t2', memberIds: ['m3', 'm5'], type: 'task' },
              ]},
              { id: 'p2_t3', name: 'D√©ploiement et Suivi', type: gantt.config.types.project, parent: p2Id, open: true, tasks: [
                  { id: 'p2_t3_1', name: 'Tests d\'int√©gration', start: startDate(38), duration: 5, progress: 0, parent: 'p2_t3', memberIds: ['m5'], type: 'task' },
                  { id: 'p2_t3_2', name: 'Mise en production', start: startDate(45), duration: 2, progress: 0, parent: 'p2_t3', memberIds: ['m2', 'm3'], type: 'task' },
              ]}
          ]
      };

      // Project 3: Formation Interne (Internal Training) - simpler project
      const p3Id = 'proj_internal_training';
      projects[p3Id] = {
          id: p3Id, name: "Formation Interne", description: "D√©veloppement d'un nouveau module de formation.", deadline: startDate(40),
          priority: 'low', color: '#F39C12', visible: true, type: gantt.config.types.project, parent: "0", open: true,
          tasks: [
              { id: 'p3_t1', name: 'Pr√©paration du contenu', start: startDate(10), duration: 8, progress: 0.75, parent: p3Id, memberIds: ['m1', 'm5'], type: 'task' },
              { id: 'p3_t2', name: 'Cr√©ation des supports', start: startDate(18), duration: 10, progress: 0.5, parent: p3Id, memberIds: ['m4'], type: 'task' },
              { id: 'p3_t3', name: 'Session de formation', start: startDate(28), duration: 3, progress: 0, parent: p3Id, memberIds: ['m1', 'm2', 'm3'], type: 'task' }
          ]
      };

      allLinks = [
          // Links for Project 1
          { id: 'l_p1_1', source: 'p1_t1_1', target: 'p1_t1_3', type: '0' },
          { id: 'l_p1_2', source: 'p1_t1_2', target: 'p1_t1_3', type: '0' },
          { id: 'l_p1_3', source: 'p1_t1_3', target: 'p1_t2_1', type: '0' },
          { id: 'l_p1_4', source: 'p1_t1_3', target: 'p1_t2_2', type: '0' },
          { id: 'l_p1_5', source: 'p1_t2_1', target: 'p1_t2_3', type: '0' },
          { id: 'l_p1_6', source: 'p1_t2_2', target: 'p1_t2_3', type: '0' },
          { id: 'l_p1_7', source: 'p1_t2_3', target: 'p1_t3_1', type: '0' },
          { id: 'l_p1_8', source: 'p1_t3_1', target: 'p1_t3_2', type: '0' },
          { id: 'l_p1_9', source: 'p1_t3_2', target: 'p1_t3_3', type: '0' },

          // Links for Project 2
          { id: 'l_p2_1', source: 'p2_t1_1', target: 'p2_t1_2', type: '0' },
          { id: 'l_p2_2', source: 'p2_t1_2', target: 'p2_t2_1', type: '0' },
          { id: 'l_p2_3', source: 'p2_t2_1', target: 'p2_t2_2', type: '0' },
          { id: 'l_p2_4', source: 'p2_t2_2', target: 'p2_t2_3', type: '0' },
          { id: 'l_p2_5', source: 'p2_t2_3', target: 'p2_t3_1', type: '0' },
          { id: 'l_p2_6', source: 'p2_t3_1', target: 'p2_t3_2', type: '0' },

          // Links for Project 3
          { id: 'l_p3_1', source: 'p3_t1', target: 'p3_t2', type: '0' },
          { id: 'l_p3_2', source: 'p3_t2', target: 'p3_t3', type: '0' }
      ];
    }
  
    function toggleTaskLock(taskId) {
        saveStateToHistory();
        const taskDataStore = findTaskInProjectsModel(taskId);
        if(taskDataStore) {
            taskDataStore.locked = !taskDataStore.locked;
            syncAndRenderGantt(); // Call central sync function
        }
    }

    function highlightOverloadDay(memberId, dateStr) {
        highlightedInfo = { taskIds: [], level: '' };
        if (dateStr) {
            const load = memberWorkload[dateStr]?.[memberId];
            if (load) {
                highlightedInfo.level = load >= 4 ? 'overload-highlight-error' : 'overload-highlight-warning';
                gantt.eachTask(function(task) {
                    if (task.type === gantt.config.types.task && (task.memberIds || []).includes(memberId)) {
                        const checkDate = gantt.date.str_to_date("%Y-%m-%d")(dateStr);
                        if (checkDate >= task.start_date && checkDate < task.end_date) {
                            highlightedInfo.taskIds.push(task.id);
                        }
                    }
                });
            }
        }
        gantt.render();
    }

    document.addEventListener('DOMContentLoaded', function () {
        // Restore scroll position from localStorage on page load
        const x = parseInt(localStorage.getItem('ganttScrollX')) || 0;
        const y = parseInt(localStorage.getItem('ganttScrollY')) || 0;

        gantt.config.date_format = "%Y-%m-%d";
        gantt.config.xml_date = "%Y-%m-%d";
        initGantt();
        document.getElementById('customLightboxTaskDuration').addEventListener('input', function() {
            updateLightboxSchedule('duration');
        });
        // Load dummy data on startup
        initDummyData(); 
        saveStateToHistory();
        setLanguage(currentLang);
        syncAndRenderGantt(); // Initial render

        // Apply restored scroll after initial render
        setTimeout(() => {
            if (typeof gantt !== 'undefined') {
                gantt.scrollTo(x, y);
            }
        }, 300);
    });

    // Save scroll position to localStorage before the page is unloaded
    window.addEventListener('beforeunload', () => {
      if (typeof gantt !== 'undefined' && gantt.getScrollState) {
        const scroll = gantt.getScrollState();
        localStorage.setItem('ganttScrollX', scroll.x);
        localStorage.setItem('ganttScrollY', scroll.y);
      }
    });

</script>

</body>
</html>
